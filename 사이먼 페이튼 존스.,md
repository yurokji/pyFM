제7장 사이먼 페이튼 존스


1987년 프로그래밍 언어 해스켈의 정의를 이끌어낸 프로젝트의 선구자 중 한 명인 Simon Peyton Jones는 영국 캠브리지에 있는 마이크로소프트 리서치 연구소의 수석 연구원이다.그는 현재 안정된 언어의 정의인 Haskell 98 Revisioned Report를 편집했습니다.haskell.org에 따르면 그는 "사실상의 표준 컴파일러"인 Glasgow Haskell 컴파일러(GHC)의 설계자이자 수석 개발자입니다.그리고 Haskell에게 널리 인용되는 비공식적인 모토를 주었습니다: "어떤 대가를 치르더라도 성공을 피하세요."

파워풀한 연구원이자 박사학위를 받은 적이 없는 전직 교수인 페이튼 존스는 실용적인 것과 이론적으로 아름다운 것 모두를 중시한다.그는 영구 저장공간이 없고 메모리 위치가 100개밖에 없는 기계로 프로그래밍하는 법을 배웠으며, 대학 시절에는 학교의 큰 다리미를 위한 고급 컴파일러 작성과 학생의 예산으로 감당할 수 있는 부품으로 자신만의 원시 컴퓨터를 만드는 일을 병행했습니다.하지만 그는 어떻게 돌연변이를 사용하지 않고 이중으로 연결된 목록을 만들 수 있는지에 대한 교수님의 설명과 게으른 평가라는 아이디어의 아름다움에 이끌렸다.페이튼 존스는 기능 프로그래밍의 아이디어를 "작성 프로그램 전체 기업에 대한 급진적이고 우아한 공격"으로 보았다. "벽에 벽돌 하나만 더 쌓는 것"이 아니라 "완전히 새로운 벽을 쌓는 방법"이다.2004년, 「기능 프로그래밍 언어에의 공헌」을 이유로, 컴퓨터·머신 협회(Association for Computing Machine)는 그를 펠로우로 선출했습니다.

우리가 이 인터뷰에서 다룬 주제 중 하나는 왜 기능적 프로그래밍이 소프트웨어의 작성 방식을 바꿀 가능성을 더 많이 보여준다고 생각하는지, 왜 소프트웨어 트랜잭션 메모리가 잠금 및 조건 변수보다 훨씬 더 좋은 동시 소프트웨어 작성 방법인지, 그리고 마이크로소프트 리서치 같은 곳에서조차 그렇게 어려운 이유였습니다.서로 다른 프로그래밍 언어가 프로그래머를 더 생산적으로 만드는지 아니면 덜 생산적으로 만드는지에 대한 실제 연구

언제 프로그래밍을 배웠어요?

페이튼 존스:학교 다닐 때.인텔은 세계 최초의 마이크로프로세서인 4004를 거의 생산했습니다.우리에겐 4004 같은 것이 없었다. 그것은 사실 취미 생활자들이 그 단계에서 거의 구할 수 없는 칩이었다.그들이 사용할 수 있는 유일한 컴퓨터는 메인프레임의 예비 부품으로 만들어진 이상한 기계인 IBM 학교 컴퓨터였다.영구 저장소가 전혀 없었기 때문에 실행할 때마다 프로그램을 입력해야 했습니다.

총 100개의 저장소가 있습니다각각 8자리 십진수를 저장할 수 있을 겁니다그리고 이것은 당신의 프로그램과 데이터를 모두 저장했습니다.프로그래밍 게임의 이름은 단순히 프로그램을 100개의 저장 장소에 맞추는 것이었습니다.어떻게 첫 프로그램을 쓰게 됐는지 기억이 잘 안 나요.나는 나와 학교의 다른 열성적인 한 명이 학교 컴퓨터에 많은 시간을 할애했다고 생각한다.이 시기는 제가 15살, 1974년, 73년 쯤이었을 겁니다. 그런 시대죠.

그리고 잠시 이 기계를 프로그래밍한 후 스윈든에 있는 기술대학에 컴퓨터가 있다는 것을 알게 되었습니다.그래서 우리는 일주일에 한 시간씩 매우 느린 버스를 타고 스윈던으로 갔습니다.거기에는 엘리엇 803이라는 거대한 기계가 있었습니다.그 기계는 하얀색 냉장고 크기의 커다란 캐비닛 6개에 하얀색 코팅을 한 오퍼레이터와 함께 살고 있었습니다.

잠시 후, 하얀 코팅을 한 작업자는 우리가 기계를 어떻게 사용하는지 알 수 있다는 것을 알게 되었고, 그녀는 우리가 이 거대한 엔진을 가지고 노는 동안 가버렸다.

그것은 종이 테이프와 텔레타이프를 사용할 수 있기 때문에, 프로그램을 종이 테이프에 보존할 수 있었습니다.우리는 알골어로 글을 썼기 때문에 그것이 나의 첫 번째 고급 언어였다.당신은 테이프에 프로그램을 쓰고 편집했죠변경하고 싶은 경우, 테이프를 텔레타이프를 통해 전송하고, 새 테이프를 인쇄하고, 적절한 위치에 정지하고, 새 비트를 입력해야 했습니다. 이는 프로그램을 편집하는 데 매우 번거로운 방법입니다.물리적 매체가 있는 라인 에디터의 일종입니다.그래서 그것이 나의 첫 프로그래밍 경험이었다.그것은 매우 동기부여가 되었다.

세이벨: 하지만 그건 학교에서 하는 강좌가 아니었어요.

페이튼 존스:안 돼! 학교에서는 컴퓨터에 대해 전혀 가르치지 않아.

그래서 그냥..."얘들아, 여기 컴퓨터 있어, 마음껏 먹어."

Peyton Jones: 물론이죠.자물쇠가 채워진 큰 찬장에 열쇠를 빌릴 수 있고, 스크린도 있고, 레지스터에 있는 것과 메모리 위치에 있는 것의 10진수만 고정된 상태로 표시되어 있습니다.프로그램을 설정하고 이동을 누를 수 있습니다.한 발짝만 내딛어도 돼정말 그랬다.ASCII 문자가 전혀 없었기 때문에 어셈블리 언어 프로그래밍도 아니었군요.말 그대로 기계코드였고 16진수가 아니라 10진수로 표시됐죠

스크린이 있었어?

페이튼 존스:텔레비전 화면이 있었어요.그것이 그것의 유일한 출력 매체였다.

어떤 정보를 얻었습니까?

페이튼 존스:그것은 일종의 터치 키보드였다.당신이 이 버튼들을 만지면 그들은 당신의 손가락이 만지는 것을 감지했다.즉, 기계식 열쇠가 없는 상당히 정교했습니다.그것은 일종의 정전용량이었다.키를 터치하면 거기에 있었다.총 20개 정도의 버튼이 있었다.

그럼 이 버튼들은 그냥 숫자용이었나요?

페이튼 존스:숫자와 Go and Step.그리고 "이 기억의 위치를 보여줘"그것은 정말로 매우 원시적이었다.그리고 그것 때문에 더욱 흥분된다.

Seibel: 이 기계에 접근하여 정보를 입력하기 전에 프로그램을 매우 상세하게 계획해야 했을 것입니다.

페이튼 존스:먼저 흐름도를 그립니다.그런 다음 지시사항으로 분류할 수 있습니다.그런 다음 명령을 이 이상한 디지털 형식으로 인코딩합니다.그리고 숫자를 입력합니다.기본적으로 프로그램인 800자리 숫자를 입력합니다.그리고 Go를 누릅니다.만약 당신이 운이 좋았다면 당신은 800자리 숫자 중 하나를 잘못 입력하지 않았고 당신은 건강했다.한 명은 화면을 보고 확인하고 다른 한 명은 "다음 장소로 가세요"라고 말하는 등 많은 시간을 할애했습니다.

그리고 제가 캠브리지 대학에 갔을 때 마이크로프로세서는 이제 막 발전하기 시작했습니다.그래서 대학 컴퓨터 동아리가 있었습니다.피닉스라고 불리는 매우 정교한 회계 시스템을 갖춘 대학 컴퓨팅 메인프레임 같은 기계가 있었습니다.

당신이 그것을 사용한 시간은 매우 의미심장했습니다.머신의 통화 단위가 일정량 할당되어 있어 프로그램이 메모리를 많이 사용할수록 더 많은 단위가 소비되고, 프로그램이 오래 걸릴수록 더 많은 단위가 소비됩니다.그러나 부하가 낮을수록 프로그램에서 소비하는 유닛의 수는 적어졌습니다.그 결과, 큰 배정을 받지 못한 우리 학부생들은 밤 9시부터 당신의 프로그램을 실행하는 것이 저렴해졌기 때문에, 단순히 그곳에서 밤을 보냈습니다.9시에서 3시 사이에 프로그램 작성에 참여하게 될 거예요.그리고 주로 뭘 썼죠?BCPL인 것 같아요.그래서 이것도 완전히 취미생활의 물건이었군요.나는 그때 수학 학위를 받고 있었다.그래서 컴퓨터 공학에서는 정규 수업이 전혀 없습니다.

그 당시에는 학부 학위도 없었다.1976년부터 79년까지요컴퓨터 공학으로 졸업할 수 있도록 기말고사 과정이 있었다.하지만 3년간의 컴퓨터 공학을 할 수는 없었습니다. 수학이나 자연과학 같은 다른 것을 미리 해야 했습니다.사실 저는 수학을 했고 1년 동안 전기과학을 공부했습니다.저는 컴퓨터가 취미라고 생각했기 때문에 학위를 따는 것도 부정 행위와 비슷합니다.학위는 어려울 것입니다.

하지만 수학은 좀 어려웠어요.왜냐하면 캠브리지에는 매우 똑똑한 수학자들이 가득 차있기 때문에 저는 전기과학을 선택했어요.

Seibel: 그리고 전기 과학은 미국에서 전기 공학이라고 부르는 건가요?

페이튼 존스:그렇다.그 당시 저와 함께 학교에 다녔던 친구 토마스 클라크도 캠브리지에 있었습니다.그래서 토마스와 나는 다양한 컴퓨터를 만들었다.마이크로프로세서와 7400 시리즈 TTL을 구입하여 배선할 수 있습니다.가장 큰 문제는 프린터였던 것으로 기억합니다.프린터와 화면그게 힘든 부분들이었어요.

시벨: 그것들은 비싸기 때문입니다.

페이튼 존스:그것들은 너무 비싸. 그래.학생들이 살 수 있는 돈이면 전기 부품을 살 수 있지만 프린터는 보통 냉장고 크기의 라인 프린터였습니다.그들은 우리의 가격대를 완전히 벗어나게 만드는 많은 기계장치를 가지고 있었다.스토리지 디바이스는 모든 종류의 영구 스토리지 디바이스는 까다로운 경향이 있었습니다.그래서 우리는 키보드, 화면, 그리고 다른 것들은 별로 없는 컴퓨터를 가지고 있는 경향이 있었습니다.그리고 일종의 원시적인 테이프 메커니즘입니다.

당신들은 76년부터 79년까지 이 컴퓨터를 처음부터 만들고 있었습니다.알테어가 나오는 시기와 비슷한 시기 아닌가요?

페이튼 존스:그렇다.확실히 취미용 컴퓨터가 나오기 시작했습니다.하지만 우리는 그것들이 오히려 속임수라고 생각했다.

우리가 직접 만든 이 기계는 소프트웨어가 문제였습니다.이 기계를 위한 가장 진보된 프로그램은 콘웨이의 게임 오브 라이프였던 것 같아요.그것은 아주 잘 작동했다.그러나 프로그래밍 언어와 같은 심각한 프로그램을 작성하는 것은 매우 제한된 영구 저장 매체를 가지고 있었기 때문에 너무 많은 작업이 필요했습니다.모두 16진수 형식으로 입력되어 있었습니다.어셈블러도 없었습니다.

더 많은 원시 기계 코드입니다.

Peyton Jones: 물론 Cambridge 메인프레임은 BCPL을 인식하고 있었기 때문에 많은 BCPL 프로그램을 작성했습니다.그때 우리는 실제로 우리가 발명한 프로그래밍 언어를 위한 컴파일러를 쓰고 있었다.우리는 이 컴파일러를 끝내지 못했다. 그것은 매우 정교했다.완전히 이혼한 두 세계가 있었어요메인프레임용 고급 언어로 컴파일러를 작성하고 반대쪽에서 하드웨어를 처리합니다.

세이벨: 당신이 쓴 첫 번째 재미있는 프로그램은 무엇입니까?

Peyton Jones: 이 학교 컴퓨터에서 24자리 제곱근을 추출하여 99개의 메모리 위치에 맞춥니다.

그럼 스페어가 하나 있었군요!

페이튼 존스:그렇다.제곱근에 대한 일종의 뉴턴-라프슨 근사치였습니다.나는 그것이 너무 자랑스러웠다.그 다음엔요?다음 스케일업은 이 컴파일러가 완성되지 않은 것이 틀림없다고 생각합니다.그것은 BCPL로 쓰여졌고 매우 정교했다.우리는 그것에 대해 매우 야망이 있었다.활자 시스템이 없었기 때문에 사진, 구조도, 화살표가 그려진 거대한 인쇄물만 있었습니다.

Seibel: BCPL에는 유형 시스템이 없었다는 말씀이시군요.

페이튼 존스:그래, 맞아.그래서 우리는 활자를 화살표로 큰 종이에 그려서 썼습니다.그건 우리 타입의 시스템이었어.그건 꽤 큰 프로그램이었어. 사실 그건 너무 야심찬 프로그램이었어. 우린 그걸 끝내지 못했어.

세이벨: 당신은 그 실패로부터 어떤 교훈을 얻었다고 생각하나요?

페이튼 존스:아마 그 때 처음으로 큰 프로그램을 작성하면 규모에 문제가 생길 수 있다는 것을 깨달았을 것입니다. 동시에 머릿속에 충분히 담아둘 수 없을 것입니다.이전에 내가 썼던 모든 것들을 당신은 문제없이 머릿속에 간직할 수 있었다.그래서 아마 제가 오랜 문서화를 진지하게 시도한 것은 이번이 처음일 것입니다.

하지만 이 경우엔 그것으로도 충분하지 않았나요?

페이튼 존스:음, 우리는 학위를 따는 것 같은 다른 할 일이 많았어.오후 9시에서 새벽 3시 사이였어요

프로그램 배우는데 뭔가 다른 걸 하고 싶은 게 있나요?

페이튼 존스:아무도 프로그래밍을 가르쳐주지 않았어요내가 그걸 놓친 적이 있는지 모르겠어.오늘날 나는 객체 지향 프로그래밍에 대한 깊고 본능적인 감각이 없다는 것이 나의 주요 프로그래밍 공백인 것 같다.물론 객체 지향 프로그램도 쓸 줄 알아요.하지만 규모에 맞게 무언가를 하면 뭔가 다른 일이 일어납니다.장기간에 걸친 대규모 프로그램을 구축하고 클래스 계층을 복잡한 방식으로 사용하고 프레임워크를 구축하는 경우, 이것이 바로 깊이 있고 본능적인 이해입니다.책에서 바로 배울 수 있는 그런 종류의 것은 아니다.

오브젝트 지향 프로그래밍으로 무엇을 할 수 있는지, 무엇을 할 수 없는지에 대해 실제로 신뢰할 수 있다고 생각하지 않기 때문에 부족하다고 생각합니다.특히 필수 프로그래밍은 매우 정교하고 풍부한 프로그래밍 패러다임이기 때문에 부정적으로 말하지 않도록 항상 조심하고 있습니다.하지만 어찌된 일인지 제 삶이 발전했기 때문에, 저는 큰 C++ 프로그램을 쓰는데 몇 년을 쓴 적이 없습니다.그렇게 하면 당신은 깊고 본능적인 느낌을 받을 수 있지만 난 그런 적이 없다.

세이벨: 나는 그 감정이 보통 혐오감이라고 생각해.

페이튼 존스:맞아요. 하지만 그건 겉만 번지르르한 혐오감이라기 보다는 잘 알고 있는 혐오감 같은 거예요.

캠브리지에서 3년을 마쳤다는 거야?

페이튼 존스:그리고 나서 저는 생각했습니다. "좋아, 컴퓨터 관련 일을 좀 하는 게 좋겠어."그래서 저는 컴퓨터 공학 대학원 졸업장을 받는 데 1년을 보냈습니다. 이것은 저의 유일한 컴퓨터 공학 정규 교육입니다.

그게 석사학위 같은 거야?

Peyton Jones: 일종의 석사 학위 같은 것입니다.나는 멋진 한 해를 보냈다.컴퓨터 공학 삼각대, 학부 학위랑 아주 비슷했을 것 같아요.

하지만 그것은 다른 컴퓨터 공학을 전혀 하지 않은 학생들을 위한 것이었다.

Seibel: 그럼 연구를 다시 시작하기 전에 몇 년 동안 산업에 종사하셨군요.그때 뭐 하고 있었어?

페이튼 존스:그 회사는 매우 작은 공정 관리 및 모니터링 회사였습니다.저희는 마이크로프로세서 기반의 컴퓨터에 탑재된 하드웨어와 소프트웨어를 만들었습니다.이 컴퓨터들은 컨베이어 벨트의 중량계 컨트롤러에 물리적으로 장착되어 있었습니다.제가 만든 것은 석탄을 운반하는 컨베이어 벨트의 로드셀을 관찰한 것입니다.컨베이어 벨트의 속도를 제어하고 로드셀의 말을 듣고 유속을 조절합니다.이것은 제가 PL/Z라는 언어로 쓴 작은 실시간 운영체제였습니다.그것은 약간 알골과 비슷했다.Z80 머신에 썼는데 크롬스라고 불리는 다운유닉스 같은 게 있어요

그것은 아주 작은 회사였다. 여섯 명이나 되는 사람들 같았다.때로는 15개까지 다양했습니다.하지만 그것은 작았기 때문에 모든 것이 꽤 불안정했다.어떤 때는 돈이 많았지만 어떤 때는 한 푼도.2년 후, 나는 기업가로서의 삶이 나에게 맞지 않는다고 결정했다.이것이 중소기업에 대한 저의 주된 통찰력입니다.기업가가 되려면 돈이 관련된 스트레스 상황에서 에너지를 얻어야 하는 반면, 제 에너지는 돈이 관련된 스트레스 상황에서 손실됩니다.제 상사는 이 회사의 상무였습니다.상황이 나빠질수록 그는 더욱 원기 왕성해질 것이다.그는 여기저기 돌아다니며 소프트웨어에 대한 새로운 기술적 아이디어를 얻곤 했다.그는 벌처럼 행복했다.그리고 깨달았습니다.그게 당신에게 필요한 것입니다.왜냐하면 에너지가 떨어지면 당신은 모든 시간을 슬럼프에 빠지기 때문입니다.

그래서 너무 힘들다고 판단하고 일자리를 찾아다니다가 결국 유니버시티 칼리지 런던 강사로 취직했습니다.제가 거기 있었을 때는 박사도 없었고, 연구 훈련도 받지 않았습니다.그래서 부서장님께서 연구할 시간을 주셨어요.내 연구를 시작할 수 있도록 가르치는 일을 가볍게 해줬지하지만 나는 어떻게 해야 할지 전혀 몰랐다.그래서 저는 사무실에 앉아서 백지와 연필을 들고 좋은 아이디어를 기다리곤 했습니다.좋은 아이디어가 나오기를 기다리는 동안 저는 일종의 침묵이 흘렀습니다.그리고 아무 일도 일어나지 않을 것이다.

존 워시브룩은 그 학과의 4학년생이었고, 저를 보호해주었고, 그는 제게 매우 중요한 이야기를 해주었습니다.그는 "아무리 겸손하더라도 무언가를 시작하라"고 말했다.이건 프로그래밍에 관한 게 아니라 연구에 관한 거예요.하지만 아무리 겸손하고 독창적이지 못하며 중요하지 않게 보일지라도, 무엇인가를 시작하고 그것에 대한 논문을 쓰세요.그래서 그렇게 했어요.그것은 매우 의미 있는 조언으로 판명되었다.

그 이후로 모든 연구생들에게 그렇게 말했어요.그렇게 시작하는 거니까요.일단 공장을 돌리기 시작하면 컴퓨터 공학은 매우 프랙탈합니다.대부분의 것은 흥미로운 것으로 판명됩니다.왜냐하면, 그 주제는 여러분보다 앞서 있기 때문입니다.그것은 당신이 발견해야 하는 고정된 것이 아닙니다.그냥 팽창해.

세이벨: 그래서 학계로 돌아왔지만 박사학위를 따지 못하셨군요.그게 어떻게 가능하죠?

페이튼 존스:요즘 박사 학위 없이 교수직을 얻는 것은 매우 어려울 것이다.1982년인가 1983년인가 봐요언니가 컴퓨터 공학을 공부하고 있어서 지원했는데 "아, UCL에 강의가 몇 개 있는데 왜 지원 안 해?"라고 하더라고요.놀랍게도 나는 임명되었다.나는 그 당시에 분명히 심각한 부족이 있었을 것이고, 컴퓨터적인 의미에서 자신을 그럴듯하게 설명할 수 있는 사람은 누구나 고용될 수 있을 것이라고 추측할 수 있을 뿐이다.그렇지 않다면 박사 학위도 없는 사람을 어떻게 고용했을까요?

UCL에서 7년을 보낸 후 나는 아마도 박사학위를 받아야겠다고 생각하기 시작했다.하지만 논문을 쓰는 건 정말 힘들었어요.하지만 캠브리지에서는 특별한 규정에 의해 박사학위를 받을 수 있습니다. 즉, 출판된 작품을 제출하면 운 좋게 "당신은 박사학위를 받아야 할 훌륭한 사람입니다." 라고 말합니다. 그래서 제가 글래스고의 교수로 임명되었을 때, 저는 그 준비를 하고 있었습니다.풀 교수님.그래서 그 무렵에는 "교수님"이라고 불려서 박사학위 소지 여부를 아무도 모르게 해서 그 아이디어를 포기했습니다.Robin Milner는 박사학위를 가지고 있지 않다. 그것은 분명 유명한 회사일 것이다.그 이후로 계속 그렇게 지내고 있어요.

세이벨: 요즘, 박사학위를 받는 것이 가치 있는 일인가요?누군가 내게 박사학위는 정말 직업학위라고 말한 적이 있다. 교수가 되고 싶다면 꼭 있어야 하지만 교수가 되고 싶지 않다면 의미가 없다.그 분석이 컴퓨터 과학에 적용된다고 생각하세요?

페이튼 존스:그 부분은 확실히 사실이다.학술적 또는 Microsoft Research나 Google의 연구소와 같은 중요한 산업 연구소에서 연구를 계속하고 싶은 경우에는 필요하지만 충분하지는 않습니다.출발점을 통과하려면 박사학위가 정말 필요해요.

연구 일을 하고 싶지 않다면, 내 생각에 그것은 당신의 마음에 따르는 것이 될 것 같아.열정적인 일을 할 때는 생산성이 5배 높아집니다."이것이 너무 좋아서 좀 더 자세히 알아보고 싶다"고 생각하는 자신을 발견한다면박사는 영국에서 3년, 혹은 미국에서 더 오래 무언가를 공부할 수 있는 훌륭한 기회입니다.정말 대단한 자유입니다. 왜냐하면 당신은 사회의 기생충 같은 존재이기 때문입니다.만약 당신이 직업으로서 풀타임 연구를 하고 싶지 않다는 것을 안다면, 박사학위를 받는 이유는 단지 열정적이고 호기심이 많고 흥미가 있기 때문입니다.하지만 어쨌든 박사들은 좀 이상하다.그들은 당신이 스스로 일하도록 강요하고, 대부분의 사람들이 읽지 않을 실질적인 논문을 만들도록 강요합니다. 그들은 당신의 논문을 읽게 될 것입니다.그래서 이건 특이한 연구 모드입니다.

박사학위를 마치면 보통 더 작고 한 입 크기의 작업에 대해 다른 많은 사람들과 더 많이 협업하기 시작할 수 있습니다.어떤 면에서는 박사학위가 연구를 위한 이상한 준비라고 생각한다.영국의 오더는 압축된 시간표 때문에.미국에서는 당신의 연구 프로그램에 집중할 때까지 잠시 더 협력할 수 있을 것 같습니다.

세이벨: 연구와 학문에 대해 말하자면, 함수 프로그래밍은 연구 커뮤니티 내에서 꽤 인기가 있지만, 저는 그 커뮤니티 밖의 많은 사람들이 함수 프로그래밍이 깔끔하지만 매우 수학적이고 일상적인 프로그래밍과는 동떨어진 아이디어에 의해 추진된다고 생각합니다.그게 공평한 특징인가요?

페이튼 존스:반쯤은 공평한 것 같아요.저는 기능 프로그래밍, 즉 단순히 기능적 프로그래밍을 특징짓고 있습니다.여기서 부작용은 어떻게든 그들만의 세계로 밀려납니다.이것은, 쓰기 프로그램의 엔터프라이즈 전체에 대한 급진적이고 우아한 공격이라고 할 수 있습니다.불규칙한 것들은 정의상 사물의 현재 상태로부터 진화하지 않는다.

오늘날 대기업들은 생태계, 에디터, 프로파일러, 도구, 프로그래머, 스킬 등에 막대한 자원을 쏟아 붓고 있습니다.주류는 정의상 매우 실용적이다.한편, 이러한 급진적이고 우아한 기능적 프로그래밍은 심층적인 인프라 지원을 훨씬 적게 제공합니다.그러나 동시에 그것이 그것을 추구하는 것을 반드시 제멋대로 하도록 만들지는 않는다.왜냐하면, 어떤 사람들이 급진적이고 우아한 일을 하지 않는 한, 당신은 결국 지역 최적화를 하게 될 것이고, 점차적으로 주류를 최적화해 나가지만 낮은 언덕에 머물게 될 것이기 때문입니다.

그래서 저는 학술연구의 모든 사업에서 좋은 점 중 하나는 교수들이 수익에 어떻게 도움이 되는지 묻지도 않고 엉뚱한 일을 할 수 있다는 것이라고 생각합니다.어떤 사람들은 환상적으로 중요한 일을 하고, 어떤 사람들은 덜 중요한 일을 할 것이다; 하지만 당신은 어느 것이 어떤 것인지 미리 구별할 수 없다!그래서 저처럼 순수하게 기능적인 프로그래밍에 많은 시간을 할애할 가치가 있는 이유는 그것이 가능성을 보여준다는 것입니다.저는 이것이 미래에 모든 사람이 프로그램을 작성하는 방식이라고 주장하고 싶지는 않지만, 그것은 가능성을 보여줍니다.그리고 저는 그것이 점점 더 유망하다는 것을 보여 줄 것입니다.필연적 프로그래밍의 석회석이 마모되면 기능적 프로그래밍의 석회석이 관찰될 것으로 본다.

그렇긴 하지만, 순수 기능적 프로그래밍은 꽤 괴짜같고 학문적이고 수학적으로 시작됐다고 생각합니다.지난 20년간, 정말이지 제가 그 일을 해온 내내, 점점 더 실용적이 되어가고 있습니다. 추상적인 아이디어뿐만 아니라 실제 프로그래머가 실제 응용 프로그램에 기능적인 프로그래밍 언어를 사용할 수 없는 장애물을 하나씩 극복하려고 노력했습니다.Haskell의 개발 자체가 그것의 한 예이다.

여기 있는 많은 사람들이 주류를 향해 가고 있다는 것은 좋은 일입니다. 어쩌면 조금 비현실적일 수도 있고, 순수하게 기능적인 세계에서 여러분이 배우는 관점이 주류를 알리고 조명할 수 있을지도 모릅니다.보시다시피, 그런 일이 일어났습니다.타입 시스템과 제네릭스에 관한 많은 것들은 원래 기능적인 프로그래밍 언어의 맥락에서 개발되었습니다.그것은 그 아이디어들 중 일부가 개발된 일종의 실험실이었다.제너레이터와 느린 스트림도 그 예입니다.Python은 구문 수준에서 목록 통합 기능을 가지고 있습니다.여러 가지 개별적인 것들이 있습니다.보통 브랜드가 변경되어 메인스트림의 상황에 맞게 상당히 변경되는 경우가 있습니다.나는 일종의 배타적 계보를 주장하고 싶지는 않지만 그럼에도 불구하고 많은 생각들이 스며들었다고 생각한다.그래서 유용했어요.

Seibel: 연구와 실제 프로그래밍의 관계는 어떻습니까?

페이튼 존스:오, 그들은 많은 교류를 합니다.제가 공부하는 분야는 프로그래밍 언어입니다.프로그래밍 언어는 결국 무엇을 위한 것일까요?프로그래밍을 쉽게 하기 위해서입니다.사실상 프로그래밍의 사용자 인터페이스입니다.그래서 프로그래밍과 프로그래밍 언어 연구는 깊은 관련이 있다.우리가 잘하지 못하는 한 가지는 푸딩의 증거는 먹는 것에 있다.그래서 프로그래머들이 먹는 것을 지켜봐야 한다는 것이다.즉, 프로그래머 프로그래밍에 대한 적절한 형식화된 연구를 수행하고 그들이 무엇을 하는지 확인해야 합니다.그리고 그것은 매우 비싸다.그리고 더 "오징어"이기도 하죠.명확한 결과를 내놓기가 더 어렵다.

그래서 프로그래밍 언어 커뮤니티의 문화는 "자신의 타입 시스템이 건전하고 완전하다는 것을 증명하라"와 같은 것입니다.우리는 아마도 그것이 실제로 사람들을 더 생산적으로 만들 수 있는지에 대한 질문에 더 중요할수록 대답을 피하지만 훨씬 더 어렵게 될 것입니다.하지만 그것들은 설득력 있게 대답하기 어려운 질문들이다.기능성 프로그램 작성과 객체 지향 프로그램 작성 중 어느 쪽이 더 생산적입니까?만약 당신이 진지한 실험을 하는데 많은 돈을 쓸 수 있다고 해도, 나는 당신이 실제로 사람들이 살 만한 결과를 얻을 수 있을지 확신할 수 없다.

작은 실험이라도 하고 계신가요?현금이 풍부한 Microsoft에서 근무하고 계시기 때문에 경험이 풍부한 Haskellite와 경험 풍부한 인력으로 구성된 팀을 구성해서 동일한 작업을 수행하고 어떤 일이 발생하는지 확인해 보시기 바랍니다.그런 종류의 테스트가 필요하겠죠, 그렇죠?

페이튼 존스:그래, 그래, 맞아.그것은 부분적으로 돈의 문제이다.하지만 그것은 단지 돈의 문제가 아니다.시간과 관심도 필요하죠그런 종류의 실험을 하는 것은 당신의 방법론 전체가 다르다.그리고 문화적으로도 전환이 필요합니다.또, Microsoft는, 외부에서는 많은 현금을 가지고 있는 것처럼 보이지만, 사실, 여기의 이야기는 주로 한 명의 연구원과 그의 워크스테이션입니다.우리는 어떤 특정한 것에만 돈을 켤 수 없다.우리가 할 수 있다면 좋을 텐데.코펠레이스에 가까운 레드몬드에는 프로토타입 제품에 대한 실험을 하는 대규모 사용성 연구소가 있습니다.새로운 버전의 Visual Studio는 광범위한 조작성 테스트를 거쳤습니다.

Seibel: 아마도 이것은 프로그래밍 언어 문제보다는 전체적인 사용자 상호작용을 위한 것일 것입니다.

페이튼 존스:API 테스트에 대한 흥미로운 작업도 하고 있습니다.Redmond의 Steven Clarke와 그의 동료들은 새로운 API가 주어진 프로그래머들이 무엇을 하려고 하는지 보고자 체계적인 시도를 해왔다.그리고 API를 설계한 사람들이 유리 스크린 뒤에 앉아서 보게 합니다.

그리고 유리창 뒤에 앉아있는 사람들이 말하길, "안돼, 안돼, 그러지 마!그건 올바른 방법이 아니야!하지만 방음이 돼요.그것은 종종 매우 유익하다는 것을 알게 된다.API를 변경합니다.솔직히, 프로그래밍 언어 연구는 그런 점에서 약하다.하지만 이것은 부분적으로 대답하기 어려운 질문들이기 때문이다.그리고 문화적으로 우리는 그것을 하는데 잘 적응하지 못한다.나는 그것을 약점으로 간주한다.하지만 개인적으로 대처할 준비가 잘 되어 있다고 느끼는 것은 아닙니다.

Seibel: 그렇다면, 연구원들이 프로그래밍을 개선하는 방법에 대한 흥미로운 아이디어를 생각해 낸다면, 연구소와 대학의 좋은 아이디어 중 가장 좋은 아이디어가 충분히 빨리 실천에 옮아갈 수 있을까요?

페이튼 존스:음, 충분히 빠르죠.나는 모른다.고객이 원하는 제품을 만드는 데 실제로 관여하고 있고, 따라서 지불할 준비가 되어 있는 사람들과 이야기할 때마다, 저는 저를 괴롭히는 많은 것들이 전혀 그들의 눈에 띄지 않는다는 것을 매우 의식합니다.

이번 주에 고객이 중시할 만한 일을 하지 않으면 안 됩니다.실효가 있을 수도 있고 어떤 면에서는 효과가 있을 수도 있지만 총체적으로는 아직 프라임 타임을 맞이할 준비가 되어 있지 않습니다.

약간의 단절이 있어요. 거긴 닭과 달걀이 얽혀 있는 문제예요.때때로 연구에서 개발된 아이디어들이 직접적으로 유용하게 쓰이기 위해서는 기초적인 연구가 아닌 테두리 주변에서 상당한 공학적 노력이 필요합니다.

나는 현장에 있는 개발자들이 이것에 대해 멍청하게 굴고 있다는 것을 암시하고 싶지는 않다. 단지 그들의 삶에 도움이 될 좋은 아이디어를 내놓지 않을 뿐이다.그들은 꽤 좋은 이유로 그들이 하고 있는 일을 하고 있다.연구용 프로토타입과 실제로 만들 수 있는 것 사이에는 약간의 차이가 있을 수 있습니다.마이크로소프트는 실제로 이 격차를 다소 메우고 있으며, 연구자와 개발자가 서로 더 밀접하게 접촉하고 경계를 넘어 작업을 진행하기 위한 추가 노력을 제공하는 것을 목적으로 하는 상당히 많은 메커니즘(인큐베이션 그룹 등)이 상당히 많기 때문입니다.그래서 MSR은 그 경계를 넘는 것에 관한 한 더할 나위 없이 좋다고 생각합니다.

이런 양파에는 층이 있어요.Java로 가득 찬 주류 개발자 숍에서 기능 프로그래밍은 프로그래밍에 대해 근본적으로 다른 사고방식일 뿐만 아니라 상호 운용에 대한 질문도 많습니다.그리고 당신은 충분한 책을 가지고 있고 충분한 도서관이 있나요?프로그래밍, 사람, 기술, 라이브러리, 프레임워크, 도구 등 모든 생태계가 있습니다.

만약 당신이 그 차단제를 충분히 가지고 있다면 당신은 막히게 될 것이다.그래서 저는 프로그래밍 언어의 연구 기술들이 스펙트럼 상의 다른 점들에 존재한다고 생각합니다.어떤 것들은 우리가 있는 곳에서 더 진화적이다."기존 프레임워크에 바로 연결되고 수정되지 않은 Java에서 작동합니다. 코드와 yeepee에 버그가 있음을 알려주는 정적 분석입니다."라고 말할 수 있습니다."프로그래밍에 대한 완전히 새로운 사고방식이 있습니다."보다 훨씬 더 쉽게 이해할 수 있습니다.

그러나 기능 프로그래밍에 대해 구체적으로 논한다면 사람들의 태도에는 질적인 변화가 있었다고 생각합니다.기능 프로그래밍에 대해 이전보다 훨씬 더 많은 사람들이 들어왔습니다.갑자기 하스켈이 무엇인지 설명하지 않아도 가끔 사람들은 "아, 들어봤어.사실 지난 주에 Slashdot에서 읽었는데 꽤 멋지다고 생각했어요."몇 년 전만 해도 그런 일은 없었어요.

하지만 그 밑바탕은 무엇일까요?그냥 뜬금없는 인기인가요?아니면 대학에서 기능 프로그래밍에 대해 배운 학생들이 더 많아져 현재는 관리직이나 상급직에 있는 경우도 있을 것이다.그럴지도 모르죠.하지만 제한되지 않은 부작용의 나쁜 결과를 다루는 소프트웨어를 확장하고, 더 많은 검증과 병렬을 다루기를 원함에 따라, 이러한 모든 문제들이 더욱 절박해 질 것입니다.나는 그것이 더 큰 관심으로 이어진다고 생각한다.이 비용/편익의 트레이드오프를 넘어 서서히 바늘이 움직이고 있다고 생각합니다.

Seibel: 언제 기능 프로그래밍을 알게 되었습니까?

페이튼 존스:기능 프로그래밍을 배운 것은 케임브리지에서의 마지막 학년 정도로 아서 노먼이 가르쳐준 짧은 코스에 진학하기 전까지였습니다.Arthur Norman은 그 학과에서 똑똑하고 약간 특이한 강사였다.기호대수에 관심이 있어서 리스프도 좋아했어요그는 어떤 부작용도 전혀 사용하지 않고 이중으로 연결된 목록을 만드는 방법을 보여주는 기능 프로그래밍에 대한 짧은 강의를 했다.저는 이것을 생생하게 기억하고 있습니다.왜냐하면, 이것은 제가 처음으로 생각한 개념이기 때문입니다.이중 링크 리스트를 작성하면, 셀을 할당해, 그 셀을 서로 가리키게 할 필요가 있다고 생각할 수 있습니다.어떻게든 부작용만 써야 할 것 같아요.

하지만 그는 순수하게 기능적인 언어로 어떻게 부작용을 사용하지 않고 실제로 쓸 수 있는지 보여주었습니다.그래서 저는 그 당시에 제가 거의 몰랐던 기능적 프로그래밍이 단순한 장난감이 아니라 꽤 흥미로운 프로그램을 만들 수 있는 매체라는 사실을 깨달았습니다.

많은 사람들이 그 데모를 보고 "오, 재미있지 않아?"라고 말하고 나서도 다시 BCPL 해킹으로 돌아갈 것입니다.왜 그렇게 멀리 도약할 수 있었을까요? 경력의 대부분을 사람들이 실제로 이 제품을 어떻게 사용할 수 있는지 보여주려고 노력하면서 말이죠?

페이튼 존스:S-K 조합기에 대한 데이비드 터너의 논문도 있습니다.S-K 콤비네이터는 람다 미적분을 번역하고 실행하는 방법입니다.람다 미적분학을 조금 배웠는데, 아마 그때 삼투술로 배웠을 거예요.터너의 논문이 보여준 것은 람다 미적분을 어떻게 S, K, I. S, K로 변환하는가 하는 것이었습니다. 그리고 나는 모두 닫힌 람다 용어입니다.즉, 실제로는 "이 복잡한 람다 용어를 이 세 가지 용어로 변환할 수 있습니다."라고 되어 있습니다.사실 나도 SKK와 같기 때문에 없앨 수 있어.

그래서 이 이상한 컴파일 단계가 있습니다. 람다 용어를 사용하여 이해할 수 있는 S와 K를 완전히 뒤죽박죽으로 만들어요. 전혀 이해할 수 없는 말이죠.하지만 이것을 논쟁에 적용하면, 기적적으로 원래의 람다와 같은 답이 계산됩니다.그리고 그것은 매우 영리하고, 그 당시에는 믿을 수 없는 것의 또 다른 예입니다.하지만 그럼에도 불구하고 당신은 그것이 항상 작동할 것이라는 것을 알 수 있었다.

무엇이 나를 흥분시켰는지 잘 모르겠다.나는 그것이 완전히 영감을 준다는 것을 알았다.하드웨어에 관심이 있기 때문에 람다 미적분을 구현할 수 있을 것 같았기 때문입니다.람다 미적분은 실행 메커니즘처럼 보이지 않기 때문입니다.약간 수학적인 사고방식이고 기계와는 좀 동떨어져 있습니다.이 S-K는 그냥 실행만 하면 되는 것처럼 보이고 실제로 실행할 수 있습니다.

S와 K가 유선 연결된 머신을 만들고 S와 K의 일련의 조작에 컴파일만 하면 된다는 생각이 들었습니다.

페이튼 존스:사실 그게 바로 내 친구들이 한 일이야.William Stoeye와 Thomas Clarke와 다른 몇몇 사람들은 S와 K를 직접 실행한 스키 머신인 SKIM을 만들었습니다.어떤 이유에서인지 나는 그 프로젝트에 직접 관여하지 않았다.하지만 그 당시에는 이런 감정이 발달하고 있었다.존 배커스의 논문 폰 노이만 스타일에서 해방될 수 있는가(Can Programming Be Reveal the von Neumann Style)는 당시 매우 영향력이 있었다.그의 튜링상 강연에서 그는 Fortran을 발명했습니다. 사실상, "기능적 프로그래밍은 미래의 방식입니다."

게다가 그는 "아마 우리는 이 일을 실행할 새로운 컴퓨터 아키텍처를 개발해야 할 것 같다"고 말했다.그래서 이 연구 분야에 대한 높은 수준의 지지는 우리가 그 논문을 미친 듯이 인용했다는 것을 의미합니다.그래서 SKIM은 그런 것의 한 예입니다.프로그램을 실행하거나 적어도 생각하는 이 특이한 방식이 전혀 다른 종류의 컴퓨터 아키텍처로 바뀔지도 모른다고 생각했습니다.이 단계는 기능 프로그래밍을 위한 급진적인 아키텍처인 1980년부터 1990년까지 지속되었습니다.나는 지금 그것이 약간 잘못된 지시라고 생각하지만 그럼에도 불구하고 그것은 끔찍하게 흥분되었다.

게으른 평가는 또 다른 큰 동기부여 요인이었다.뒤늦게 깨달은 덕분에 나는 게으른 평가가 훌륭하다고 생각하지만 그 당시에는 그것이 일종의 중추적이었다.게으른 평가는 함수가 그들의 주장을 평가하지 않는다는 생각이다.다시 한 번 동기 부여 요소는 그것이 아름답고 우아하며 특이하고 급진적인 것과 관련이 있었다.

이것은 상상력을 끌어내는 데 도움이 됩니다.이것은 완전히 새로운 방식으로 프로그래밍을 생각하는 것처럼 보입니다.벽에 벽돌 하나만 더 붙이는 게 아니라 완전히 새로운 벽을 만들 수 있어.정말 신나요.나는 그것에 강한 자극을 받았다.그냥 깔끔한 속임수였나요?어떤 면에서는 깔끔한 속임수가 매우 중요하다고 생각한다.게으른 평가는 매우 깔끔하고 불가능하다고 생각되는 놀라운 다른 일들을 할 수 있다.

예를 들면?

페이튼 존스:나는 내 친구 존 휴즈가 나를 위해 프로그램을 만든 것을 기억한다.프로젝트를 위해 람다 미적분의 두 가지 구현과 성능을 비교하고 있었기 때문에 존이 몇 가지 테스트 프로그램을 주었습니다.그 중 하나는 e의 소수점 확장을 임의의 정밀도로 계산하는 프로그램이었다.그것은 게으른 프로그램이었다. 모든 e자릿수를 만들어냈기 때문에 오히려 아름다웠다.

세이벨: 결국엔.

페이튼 존스:결국, 맞아요.하지만 그것은 소비자에게 달렸다.몇 자리 숫자를 미리 말할 필요가 없었습니다.이 리스트가 주어졌을 뿐이고, 리스트의 요소를 계속 끌어당겨도 충분한 사이클을 거쳐 계산될 때까지 더 이상의 숫자를 얻을 수 없습니다.C 프로그램을 작성한다면 그렇게 쉽게 할 수 있는 일이 아닙니다.사실 당신은 충분히 영리하게 그것을 할 수 있다.하지만 이것은 C의 자연스러운 프로그래밍 패러다임이 아닙니다.당신은 게으른 기능 프로그램을 본 후에만 그것을 할 수 있다.반면 존의 프로그램은 네댓 줄에 불과했다.신기하네요.

Seibel: 다른 언어들은 Python의 생성기 같은 값을 산출할 수 있는 것들을 사용하여 그러한 종류의 연산을 특수하게 표현하고 있습니다."아하, 우리는 그저 지칠 때까지 답을 도출하고 싶은 무한한 일련의 계산으로 볼 수 있는 많은 것들이 있다."라고 말하게 만드는 무언가가 있었나요?"오, 그것은 어떤 문제에 대한 흥미로운 기술이지 모든 것의 기초는 아니다."라고 말하는 것과는 반대됩니다.

페이튼 존스:이 단계에서 나는 그렇게 반성하지 않았다고 생각한다.난 그냥 그게 너무 멋지다고 생각했어.그리고 재밌어요.저는 동기부여가 되고 재미있다고 생각되는 것을 하고 그것을 따르는 것이 중요하다고 생각합니다.난 그게 아주 고무적이라고 느꼈어.나는 이것이 프로그래밍을 하는 방법이라는 원리가 있는 깊은 이유가 있다고 생각하지 않는다.프로그래밍을 하는 데 아주 좋은 방법이라고 생각했어요.나는 스키를 좋아한다.그런데 왜 내가 스키를 좋아할까?그것이 세상을 바꿀 것이기 때문이 아니라, 단지 그것이 매우 재미있기 때문입니다.

나는 게으름의 중요한 점은 우리를 순수하게 유지시켜준다는 것이라고 생각한다.아마 제 강연에서 몇 번 보셨을 겁니다.하지만 사실 나는 게으름을 정말 좋아해.선택권이 주어진다면 나는 게으른 언어를 선택할 것이다.모든 종류의 프로그래밍에 정말 도움이 되는 것 같아요.저는 여러분이 존 휴즈의 "기능 프로그래밍이 중요한 이유"라는 논문을 읽으셨을 거라고 확신합니다.이것은 게으름이 귀여운 것 이상으로 중요한 이유에 대한 가장 초기의 명확한 설명일 것이다.그의 주된 이야기는 모듈러 프로그램을 만드는 데 도움이 된다는 것입니다.

느긋한 평가를 통해 생성기를 작성할 수 있습니다. 예를 들어 체스 게임에서 가능한 모든 동작을 생성하는 경우입니다. 생성기는 트리 위를 걸어다니며 알파 베타 최소화를 수행하는 소비자와는 별도로 작성됩니다.또는 모든 근사치를 생성하는 경우, 언제 멈춰야 하는지 말하는 소비자가 있습니다.발전기를 소비자로부터 분리함으로써 프로그램을 모듈식으로 분해할 수 있는 것으로 나타났습니다.한편, 언제 중단해야 하는지 말하는 소비자와 함께 생성해야 한다면, 프로그램이 훨씬 덜 모듈화 될 수 있습니다.함께 구성될 수 있는 별개의 장소에 있는 분리된 생각이라는 의미에서 모듈러형입니다.John의 논문은 서로 독립적으로 전기 소비 장치를 변경하거나 발전기를 교체할 수 있는 몇 가지 좋은 예를 제시합니다. 이렇게 하면 서로 밀접하게 얽혀 있는 프로그램을 수정하는 것이 더 어려웠을 새로운 프로그램을 결합할 수 있습니다.

그래서 그게 게으름이 왜 좋은지에 대한 모든 것이다.또, 프로그램의 로컬 레벨에서도 매우 도움이 됩니다.Haskell 프로그래머는 함수 정의를 로컬 정의와 함께 적는 경향이 있습니다.그래서 그들은 "f of x = blah, blah, blah, blah where..." 라고 말할 것입니다.그리고 여기서 그들은 많은 정의와 정의들을 적습니다.모든 경우에 필요한 것은 아닙니다.그래도 그냥 적어두면 돼.필요한 것은 평가되고 필요 없는 것은 평가되지 않습니다.따라서 "어머나, 이 모든 하위 표현식은 평가되지만, 0으로 나누기 때문에 충돌하기 때문에 이 정의를 조건의 오른쪽 분기로 이동시켜야 하기 때문에 평가할 수 없습니다."라고 생각할 필요는 없습니다.

그런 거 없어요.필요할 수 있는 보조 정의와 필요한 정의만 적는 경향이 있습니다.프로그래밍의 편리함 같은 거죠.매우 편리한 메커니즘입니다.

하지만 다시 큰 그림으로 돌아가서, 게으른 평가자가 있다면, 표현이 언제 평가될지 정확히 예측하는 것은 어렵습니다.즉, 화면에 무언가를 인쇄하고 싶은 경우, 평가 순서가 완전히 명시되어 있는 모든 콜 바이 밸류 언어는 불순한 "함수"를 가지고 있어야 합니다.: 문자열과 유닛을 조합한 타입으로 함수가 전혀 아니기 때문에 따옴표를 붙입니다.이 기능을 '부작용'이라고 부르면 화면에 뭔가 표시된다.리스프에서도 마찬가지입니다.ML에서도 마찬가지입니다.기본적으로 모든 가치별 호출 언어로 이루어집니다.

순수한 언어에서는 문자열에서 단위까지의 함수를 사용할 경우, 이 함수를 호출할 필요가 없습니다. 왜냐하면 이 함수는 정답 단위만 제공되기 때문입니다.그게 함수가 할 수 있는 전부야, 답을 주는 거지.그리고 당신은 답이 무엇인지 알고 있다.하지만 물론 부작용이 있다면 그렇게 부르는 것이 매우 중요합니다.느린 언어에서 문제는 "f applyed to print "hello"라고 말하면 f가 첫 번째 인수를 평가하는지 함수의 호출자에게 명확하지 않다는 것입니다.함수의 내부와 관련이 있습니다.두 개의 인수('hello'와 'goodbye')를 건네주면 둘 중 하나 또는 둘 다 순서대로 인쇄하거나 둘 다 인쇄하지 않을 수 있습니다.따라서, 느긋한 평가에서는, 입력/출력을 부작용으로 하는 것은 실현 가능하지 않습니다.그런 방법으로는 합리적이고 신뢰할 수 있고 예측 가능한 프로그램을 작성할 수 없습니다.그래서 우리는 참아야 했다.당신이 말할 수 있는 어떤 입력/출력도 재구성할 수 없었기 때문에 그것은 정말 창피했다.그래서 오랫동안 우리는 기본적으로 하나의 문자열로 묶을 수 있는 프로그램을 가지고 있었습니다.그게 프로그램 전체가 한 일이었어요.입력 문자열은 입력 문자열이고 결과 문자열은 출력 문자열이며 프로그램이 실제로 할 수 있는 것은 이것뿐입니다.

일부 외부 인터프리터에 의해 해석된 출력 명령어를 출력 문자열에 부호화함으로써 보다 스마트한 기능을 얻을 수 있습니다.따라서 출력 문자열에 "화면에 인쇄하고 디스크에 저장"이라고 표시될 수 있습니다.통역사는 실제로 그렇게 할 수 있습니다.기능적인 프로그램은 모두 훌륭하고 순수하며 일련의 명령어를 해석하는 사악한 통역기가 있다고 상상해보세요.하지만 물론 파일을 읽으면 어떻게 하면 프로그램에 입력 정보를 다시 가져올 수 있을까요?음, 그건 문제가 되지 않아요. 왜냐하면 당신은 사악한 인터프리터에 의해 해석된 일련의 명령어를 출력할 수 있고 느린 평가를 사용할 수 있기 때문에, 그것은 그 결과를 프로그램의 입력으로 다시 덤프할 수 있기 때문입니다.따라서 이 프로그램은 일련의 요청에 대한 일련의 응답을 받습니다.세상에 이런 짓을 하는 사악한 통역사에게 부탁이 빗발칩니다.각 요청은 응답을 생성하여 입력에 피드백합니다.또한 평가는 게으르기 때문에 프로그램은 루프를 돌고 입력으로 소비되는 시간에 맞춰 응답을 내보냈습니다.하지만 너무 열심히 반응하면 교착상태에 빠지기 때문에 조금 취약했습니다.왜냐하면 당신은 아직 대답하지 않은 질문에 대한 답을 요구할 것이기 때문입니다.

이 문제의 요점은 게으름으로 인해 I/O 문제를 해결할 방법을 생각해야 하는 궁지에 몰렸다는 것입니다.나는 그것이 매우 중요하다고 생각한다.게으름의 가장 중요한 점은 우리를 그곳으로 이끌었다는 것이다.하지만 시작은 그렇지 않았다.게으름은 쿨한 것이다. 얼마나 훌륭한 프로그래밍 숙어인가.

프로그래밍을 시작한 후 프로그래밍에 대해 어떻게 생각하시는지요?

페이튼 존스:프로그래밍에 대한 제 생각의 큰 변화는 아마도 모나드와 타이프 시스템과 관련이 있다고 생각합니다.80년대 초반과 비교하면 비교적 단순한 타입의 순수 함수형 프로그래밍을 생각하면 이제는 모나드에 의해 매개되는 순수 함수형, 필수형, 동시형 프로그래밍이 혼합되어 있다고 생각합니다.그리고 타입은 훨씬 더 정교해졌고, 그 단계에서 생각했던 것보다 훨씬 다양한 프로그램을 표현할 수 있게 되었습니다.두 가지 모두 다소 진화적이라고 볼 수 있을 것 같습니다.

Seibel: 예를 들어, 컴파일러의 기입을 처음 시도했을 때부터 많은 컴파일러를 작성했습니다.당신은 지금 그것을 성공적으로 할 수 있는 몇 가지 방법을 배웠을 것입니다.

Peyton Jones: 네. 음, 많은 것들이 있습니다.물론 그것은 명령어로 쓰여진 명령어 컴파일러였다.이제 기능 언어용 컴파일러를 기능 언어로 쓰고 있습니다.하지만 Haskell용 컴파일러인 GHC의 큰 특징은 사용하는 중간 언어 자체가 입력된다는 것입니다.

중간 표기의 타이핑은 원래 소스로부터의 타이핑만으로 이루어집니까?

페이튼 존스:네, 하지만 훨씬 더 명확해요.원본 소스에서는 많은 유형 추론이 진행 중이며 소스 언어는 유형 추론이 가능하도록 세심하게 제작되었습니다.중간 언어에서, 유형 체계는 훨씬 더 일반적이고, 훨씬 더 표현적입니다. 왜냐하면 더 명확하기 때문입니다: 모든 함수 인수는 그 유형으로 장식됩니다.유형 추론은 없고 중간 언어를 확인하는 유형일 뿐입니다.즉, 명시적으로 입력된 언어인 반면, 소스 언어는 암묵적으로 입력된 언어인 것입니다.

유형 추론은 유형 추론 엔진이 알아낼 수 있는 범위 내에서만 적합하도록 신중하게 선택된 규칙 집합을 기반으로 합니다.소스 대 소스 변환으로 프로그램을 변환하면 그 경계 밖으로 이동했을 수 있습니다.유형 추론은 더 이상 도달할 수 없습니다.따라서 최적화에 좋지 않습니다.최적화가 유형 추론의 경계를 벗어났는지 여부에 대해 걱정할 필요가 없습니다.

Seibel: 그러면 올바른 프로그램이 있다는 것을 알 수 있습니다.왜냐하면, 당신이 그것을 손으로 썼다면 컴파일러는 "죄송합니다.이것을 타이핑할 수 없습니다."라고 말했을 것입니다.

Peyton Jones: 맞아요.이것이 정적 유형의 시스템의 특성이며, 동적 언어가 여전히 흥미롭고 중요한 이유입니다.특정 유형의 시스템으로 입력할 수 없지만 실행 시 "잘못"되지 않는 프로그램도 있습니다.이것은 골드 스탠다드입니다.세그 폴트나 문자에 정수를 추가하지 마십시오.그들은 괜찮아.

Seibel: 그래서 다이내믹 타이핑과 스태틱 타이핑을 옹호하는 사람들이 언쟁을 벌일 때, "그런 프로그램들이 많이 있습니다. 스태틱 타이핑은 제가 쓰고 싶은 프로그램을 작성하는 데 방해가 됩니다."그리고 나서 정적 타이핑의 팬들은 "아뇨, 존재하지만 실제로는 문제가 되지 않습니다."라고 말한다.그것에 대해 어떻게 생각하세요?

페이튼 존스:그것은 부분적으로 단순한 친밀함과 관련이 있다.마치 내가 C++ 프로그램을 쓰는 것에 대한 본능적인 느낌이 없다고 말하는 것과 같다.아니면, 당신은 게으른 평가를 한 번도 받아본 적이 없기 때문에 놓치지 않는 반면, 나는 그것을 많이 사용할 것이기 때문에 놓칠 것이다.동적 타이핑은 약간 그런 것 같아요.문화적으로 편향되어 있기 때문에 특히 이러한 매우 풍부한 타입의 시스템에서는 큰 프로그램 덩어리가 정적으로 잘 타이핑될 수 있다고 생각합니다.그리고 가능한 한 광범위하게 연습된 이유들로 인해 매우 가치가 있습니다.

하지만 연습이 덜 된 것은 유지 보수이다.3년 전에 작성한 코드 덩어리가 있고, 그 코드 덩어리를 시스템적으로 변경하고 싶을 때(단순히 하나의 프로시저를 조정하는 것 뿐만이 아니라, 광범위한 효과를 가져오는 것)에는, 타입의 시스템이 매우 도움이 됩니다.

이것은 델의 컴파일러에서 발생합니다.GHC나 컴파일러에 퍼진 데이터 표현에 변경을 가할 수 있습니다.또, 그것들이 사용되고 있는 장소를 모두 찾아냈다고 확신할 수 있습니다.좀 더 역동적인 언어로 표현하면 굉장히 불안할 것 같아요.컴파일러를 놓쳐서 컴파일러를 보냈는데, 그 컴파일러가 제가 가지고 있지 않은 데이터를 입력해 주었는데, 제가 계속 변경하지 않은 데이터에 걸려 버렸다는 것이 불안했습니다.

정적 유형도 프로그램의 기능에 대한 설명의 일부를 수행한다고 생각합니다.이 프로그램이 하는 일에 대해 제가 무언가를 말할 수 있는 작은 언어입니다만, 너무 많이 말할 수는 없습니다.사람들은 종종 "기능적인 언어의 UML 다이어그램과 동등한 것은 무엇입니까?"라고 묻습니다.제가 생각해낸 최고의 답은 바로 타입 시스템입니다.오브젝트 지향의 프로그래머가 그림을 그릴 때, 저는 거기에 앉아서 글씨체 서명을 쓰고 있습니다.도표는 아니지만 정식 언어이기 때문에 프로그램 텍스트의 영속적인 부분을 형성하고 제가 쓴 코드와 대조하여 정적으로 체크됩니다.그래서 그들은 모든 종류의 좋은 특성도 가지고 있다.프로그램 작업의 일부에 대한 아키텍처 설명과 거의 비슷합니다.

세이벨: 그래서 당신은 당신이 옳다고 알고 있지만 어떻게든 타이프 체커의 범위를 벗어나는 프로그램을 작성한 적이 있나요?

페이튼 존스:이것은 범용 프로그래밍을 할 때 표시됩니다.예를 들어, 모든 종류의 데이터를 취득해, 그 데이터를 간단하게 읽어내 시리얼화하는 함수를 기술하고 싶은 경우입니다.그래서 이 시기에는 활자가 좀 어색할 수 있고 활자가 없는 언어는 특히 직설적입니다.타이핑되지 않은 언어로 연재기를 쓰는 것이 더 쉬울 수 없다.

이제는 일반 프로그램을 만드는 교묘한 방법을 설명하는 사람들의 작은 가내 산업이 있습니다.저는 그런 것들이 신기하다고 생각해요.하지만 이것은 역동적으로 타이핑된 언어로 쓰는 것만큼 간단하지 않다.존 휴즈를 설득해서 기능 프로그래밍 저널에 정적 타이핑이 왜 나쁜지에 대한 논문을 쓰도록 하고 있어요.왜냐하면 저는 존의 논문이 매우 흥미로울 것 같기 때문입니다. 존의 논문은 주류이고, 매우 강력하고, 매우 정교한 기능 프로그래머입니다. 그는 지금 무타형 얼랑에서 많은 작업을 하고 있습니다. 정적 타입이 왜 나쁜지에 대해 말하고 있습니다.나는 그가 매우 반성적이고 흥미로운 논문을 쓸 것이라고 생각한다.우리가 어디로 갈지 잘 모르겠어요.

저는 여전히 "정적 타이핑이 맞는 곳에서는 매번 해야 합니다. 왜냐하면 유지보수의 이점이 매우 높기 때문입니다."라고 말할 것입니다.프로그램을 생각하는 데 도움이 됩니다.작성하는 데 도움이 됩니다하지만 점점 더 정교한 유형의 시스템을 만들고 있다는 사실은 더 많은 프로그램을 다루기 위해 경계를 넓히려고 노력하고 있다는 것을 보여줍니다.그래서 이야기는 아직 끝나지 않았다.

의존적인 타입의 프로그래밍 사람들은 "궁극적으로 타입 시스템은 어떤 것이든 표현할 수 있어야 한다"고 말할 것이다.그러나 타입은 재미있는 것입니다.타입은 매우 콤팩트한 사양 언어입니다.기능에 대해서는 뭐라고 하지만, 한 번에 머릿속에 들어갈 수 없을 정도로 많이는 말하지 않습니다.그래서 타입의 중요한 점은 바삭바삭하다는 것입니다.2페이지 동안 계속되면 모든 정보를 전달하는 것을 멈춥니다.

제가 바라는 것은 조금 약하고 빳빳하고 컴팩트한 타입을 가지고 있는 것입니다.그래서 불변성과 함께 아마 불변형보다 더 풍부한 언어로 표현될 수 있지만 정적 체크가 가능한 타입입니다.다른 프로젝트에서 작업 중인 것은 사전 및 사후 조건과 데이터 유형의 불변성에 대한 정적 검증을 시도하는 것입니다.

세이벨: 에펠의 설계 계약과 유사합니까?

페이튼 존스:그렇다."0보다 큰 인수를 주면 0보다 작은 결과를 주겠다"와 같은 함수에 대한 계약서를 작성할 수 있습니다.

소프트웨어 디자인은 어떻게 합니까?

페이튼 존스:보통 프로그램 작성에 대해 생각할 때 GHC의 새로운 부분을 작성하는 것에 대해 생각할 때 가장 큰 문제는 아이디어를 코드화하는 방법이 아니라고 생각합니다.하지만, 오히려, 무슨 생각일까?

예를 들어, 현재 우리는 GHC의 백엔드와 코드 생성 부분을 새로운 방식으로 리팩터링하기 위해 비행 중에 있습니다.현재 컴파일러에는 기본적으로 기능적인 언어를 C-로 변환하는 단계가 있습니다.이것은 명령어입니다.그리고 그것은 꽤 큰 진전이다.C라고 하는 이유는 C의 부분집합과 같기 때문입니다.하지만 이건 정말 휴대용 어셈블리 언어입니다.ASCII로 출력되는 것이 아니라 내부 데이터 유형일 뿐입니다.따라서 컴파일러의 이 단계는 기능 프로그램을 나타내는 데이터 구조에서 필수 프로그램을 나타내는 데이터 구조까지의 함수입니다.그 스텝은 어떻게 만들어요?

음, 지금은 그렇게 할 수 있는 꽤 복잡한 코드를 가지고 있어요.그러나 며칠 전 두 부분으로 나눌 수 있다는 것을 깨달았습니다.처음에는 프로시저 호출이 가능한 C-사투리로 변환됩니다.프로시저 내에서 프로시저를 호출할 수 있습니다.그런 다음 콜이 없는 하위 언어로 변환합니다.테일 콜만 있습니다.

그렇다면 이 게임의 이름은 데이터 유형이 무엇인지 알아내는 것입니다.이 C-물건, 뭐야?필수 프로그램을 나타내는 데이터 구조입니다.그리고 두 번째 단계를 밟을 때 프로그램을 훑어보고,

한 번에 하나씩 보면서따라서 집중력이 제어 흐름 아래로 이동하거나 제어 흐름을 통해 다시 올라갑니다.이를 표현하는 데 적합한 데이터 구조를 "지퍼"라고 합니다. 이는 순전히 기능적인 데이터 구조 중심으로 초점을 이동시키는 데 매우 유용한 순수 기능적인 데이터 구조입니다.

하버드의 Norman Ramsey는 이것을 필수 제어 흐름 그래프를 나타내는 데이터 구조 주변을 걷는 데 사용할 수 있는 방법을 찾았습니다.그래서 저와 존 디아스는 GHC의 백엔지니어링을 통해 이 기술을 도입했습니다.이를 통해 이 백엔드를 다른 언어의 백엔드로 사용할 수 있게 되었습니다.

우리의 논의의 대부분은 본질적으로 유형 수준이었다.Norman은 "여기 API가 있어요"라고 활자 서명을 해서 말했고, 저는 "너무 복잡해 보이는데, 왜 그런 거죠?"라고 말했습니다.그는 이유를 설명했고 나는 이렇게 말했다. "이렇게 하면 더 간단할 수 없을까?"그래서 우리는 유형을 설명하는 수준에서 왔다 갔다 하는 데 많은 시간을 할애했습니다.

그러나 대부분의 경우 프로그래밍에 관한 것이 아니라 아이디어에 관한 것이었습니다.그런데 이 데이터 흐름 분석을 어떻게 해야 할까요?프로그램의 이 단계가 무엇을 의도하는지 명확하게 말하려고 합니다.그래서 우리는 입력과 출력이 무엇인지 명확히 하고 입력과 출력의 데이터 유형을 연구하는데 많은 시간을 소비했습니다.데이터 타입을 올바르게 하기 위해서입니다만, 프로그램의 기능에 대해서는 이미 많은 것을 언급하고 있습니다.사실 놀랄 만큼 많은 양입니다.

Seibel: 그 종류에 대해 생각하는 것이 실제로 앉아서 코딩하는 것과 어떤 관련이 있나요?유형을 스케치하면 앉아서 코드를 작성할 수 있습니까?아니면 코드를 쓰는 행위가 그 유형에 대한 이해를 되살려 주나요?

페이튼 존스:오, 후자가 더 많죠, 네.지금 바로 타이프 서명을 파일로 작성하겠습니다.사실 그런 종류의 값을 조작하는 코드를 작성하게 될 것 같습니다.그럼 다시 돌아가서 데이터 유형을 변경하겠습니다.이것은 2단계 과정이 아닙니다. "이제 타이프를 다 쳤으니 코드를 쓸 수 있어요."

나는 이 일에 대해 조금 훈련받지 못했다.이것은 큰 팀의 일원으로서 일하지 않는 데서 비롯된다.코드 작업을 할 때 한 사람이 더 큰 팀에서는 할 수 없었던 일을 할 수 있습니다.

Seibel: GHC의 최근 코드 격변에서 상황은 훨씬 더 일반적이 되었다고 말씀하셨습니다.GHC는 시간이 지남에 따라 발전한 큰 프로그램이기 때문에 일반성의 혜택을 받을 수 있는 기회와 과도한 일반성의 비용을 지불할 수 있는 기회가 있었습니다.과잉 일반화와 과소 일반화의 균형을 맞추는 방법에 대해 배운 것이 있습니까?

페이튼 존스:제 기본은 처음부터 아주 일반적인 것을 쓰지 않는 것이라고 생각합니다.그래서 나는 가능한 한 내 프로그램을 아름답게 만들려고 노력하지만, 가능한 한 일반적이지는 않다.차이가 있어요.저는 가능한 한 명확하고 명료하게 작업을 수행할 수 있는 코드를 작성하려고 합니다.내가 같은 코드를 여러 번 쓰고 있다는 것을 깨달았을 때에만, 나는 "아, 그냥 한 번만 하고, 두 가지 사이에 다른 비트에 대해 파라미터를 설정하기 위해 몇 가지 추가 인수를 전달하자."라고 생각할 것이다.

Seibel: 실제 프로그래밍 환경은 무엇입니까?어떤 도구를 사용하십니까?

페이튼 존스:오, 끔찍하게 원시적이네요.나는 Emacs와 함께 거기 앉아서 GHC와 컴파일을 한다.그게 다예요.델의 컴파일러에는 프로파일링 툴이 포함되어 있으며, Haskell 프로그램의 프로파일링에 자주 사용됩니다.컴파일러 자체를 프로파일링하기 위해서입니다.GHC는 중간 출력을 많이 덤프해서 무슨 일이 일어나고 있는지 볼 수 있어요.

디버깅은 컴파일러가 좋은 코드를 생성하지 못하는 경우가 많기 때문에 저는 그 내장의 상태를 주시하고 있습니다.아니면 이 작은 소스 프로그램을 이렇게까지 컴파일해서 보세요그게 디버깅이에요.프로그램을 한 번에 훑어보는 일은 거의 없습니다. 컴파일할 때 서로 다른 부품의 값을 더 자세히 살펴봅니다.

난 정교한 에맥스 지그포커리도 가지고 있지 않아어떤 사람들은 그렇게 하죠.또한 Visual Studio나 Eclipse 같은 IDE에 익숙한 많은 사람들이 있습니다.기능적 프로그래밍 언어를 채택하는 데 있어 문화적 장벽은 ID 스토리를 정리하지 못한 데 있다고 생각합니다.여기에 닭과 달걀의 문제가 좀 있다.현재 치킨은 점점 더 바빠지고 있습니다. 일반적으로 기능적 프로그래밍에 더 많은 관심이 있습니다.나는 그것이 달걀에 대한 작업을 자극하기를 바란다.Haskell을 위한 IDE를 구축하려면 많은 엔지니어링이 필요합니다.Visual Studio를 쉘로 하거나 Eclipse를 쉘로 사용하더라도 매우 부드럽고 모든 것이 제대로 작동하는 플러그인을 만드는 데 많은 작업이 필요합니다.

Seibel: GHC에는 Read-Eval-Print 루프, GHCI가 있습니다.하스켈 프로그램을 인터랙티브하게 관리하나요?

페이튼 존스:사실 저는 편집과 컴파일을 주로 하는 편이에요.하지만 다른 사람들은 평생 GHCI에서 살아.

테스트에 관해서는 기능언어의 좋은 점 중 하나는 프로그램 내에서 작은 기능을 테스트하고 싶을 때 입력이 어떤 형태로 되어 있는지 알아내야 한다는 것입니다.

페이튼 존스:글쎄요, 저는 입력 데이터가 그렇게 간단하다면 제 프로그램에는 문제가 없을 겁니다.제 프로그램의 문제는 GHC가 컴파일하려고 하는 꽤 큰 입력 프로그램이 될 것이고 그에 대한 오답이 나올 것입니다.

테스트는 속성 기록 시 매우 중요하며 QuickCheck 속성은 매우 유용합니다.QuickCheck는 유형에 따라 함수의 랜덤 테스트를 생성하기 위한 Haskell 라이브러리입니다.하지만 왜 Quick Check를 사용하지 않는지 생각해 보았습니다. Quick Check는 매우 좋은 도구입니다.문제가 되는 상황은 테스트 데이터를 생성하기 어려운 상황이기 때문인 것 같습니다.어쨌든 GHC를 토해내는 프로그램을 만들고 있는 사람은 많습니다.그게 바로 GHC의 버그 트래커입니다.

그래서 보통 전 이미 옳지 않은 것부터 시작합니다.컴파일러가 완전히 실패하거나 프로그램을 거부하면 안 될 수도 있습니다.아니면 최적의 코드를 생성할 수도 있습니다.악성코드만 생성된다면 컴파일 파이프라인의 여러 단계에서 코드를 보고 "그때는 좋아보이고, 그땐 좋아보입니다.아, 여기 상황이 안 좋아졌는데 뭐가 잘못됐지?"

어떻게 생각하세요?

Peyton Jones: GHC는 깃발을 가지고 있습니다. 깃발에 따라 여러 가지를 인쇄합니다.

Seibel: 내장된 인쇄문 디버깅?

Peyton Jones: 네. 그리고 그 구조는 대부분의 컴파일러와 비슷하다는 사실에 도움을 받았습니다. 그것은 일어나는 일들의 파이프라인의 최상급 구조를 가지고 있습니다.중간에 뭔가 잘못됐다면 그게 좀 더 까다로울 수도 있어하지만 저는 디버깅 기술이 좀 서툴러요.이 패스 전후 프로그램만 보여주세요.아아, 뭐가 잘못됐는지 알겠어.또는 문제가 무엇인지 알 수 없기 때문에 안전하지 않은 인쇄용 F를 몇 개 뿌려 실제로 무슨 일이 일어나고 있는지 확인할 수도 있습니다.

Haskell에는 다양한 디버깅 환경이 있습니다.여름 학생인 Pepe Iborra는 올해 초에 좋은 디버깅 환경을 만들었습니다.GHC는 일종의 인터랙티브 디버거입니다.아직 많이 안 써봤는데그 이유 중 하나는 오랫동안 사용하지 않았기 때문이기도 합니다. 기능 프로그램을 어떻게 한 단계씩 진행해야 하는지가 명확하지 않기 때문입니다.

기능 프로그램을 어떻게 디버깅할 것인가에 대한 흥미로운 연구 질문입니다.그 상자를 쉽게 체크할 수 없다는 것은 조금 부끄럽지만, 흥미로운 연구 문제가 되고 있습니다.

안전하지 않은 프린트에 대해 매우 조잡한 디버깅 기술을 사용하는 경향이 있다는 것은 먼 이야기다.그리고 난 그게 별로 자랑스럽지 않아하지만 오랫동안 우리는 다른 아무것도 가지고 있지 않았다.적어도 GHC에 관한 한, 저는 그것이 저에게 있어서 가장 빠른 완성이라는 것을 의미하는 메커니즘을 발전시켜 왔습니다.

세이벨: 그것은 흔한 이야기인 것 같다.이렇게 많은 사람들이 인쇄문 디버깅으로 그럭저럭 살아가고 있다면 더 나은 디버깅을 쓰는 것이 어떤 효용인지 궁금하게 만들 것이다.

페이튼 존스:근데 문화적인 게 있어요.에서.디버거를 탑재한 NET 플랫폼은 수십 년 또는 수백 년 동안 엔지니어링에 투입되어 왔습니다.질적으로 다른 경험이라고 생각합니다.디버거가 제대로 작동하기 위해서는 아마도 더 많은 엔지니어링 사이클이 필요할 것 같습니다.하지만 그것들을 넣으면, 정말로 훨씬 더 도움이 되는 것을 얻을 수 있습니다.

아마도 당신이 주로 이야기했던 사람들은 학술 소프트웨어 틀에 더 가까울 것이다.또, 고도의 디버깅 환경에서도 성장하지 않았을 가능성이 있습니다.저는 일반적인 레슨을 받고 싶지 않습니다.좋은 디버깅 환경의 중요성을 폄하하거나 경시하고 싶지는 않습니다.특히 소프트웨어 층이 매우 많은 복잡한 이러한 생태계에서는 더욱 그렇습니다.GHC는 풀온에 비해 매우 간단한 시스템입니다.DOM 및 UML 층이 있는 NET 환경, 어떤 종류의 goop인지 알 수 없습니다.현실 세계는 너무 복잡해지기 때문에 더 많은 기계적인 지원이 매우 중요할 수 있다.

Seibel: 올바른 소프트웨어를 얻기 위한 또 다른 접근법은 공식적인 증거를 사용하는 것입니다.당신은 그것이 유용할 것이라는 전망에 대해 어떻게 생각하십니까?

페이튼 존스:모든 것이 기계에서 검사한 정확성 증명을 갖는 것이 목표라고 선언했다고 가정합니다.그게 무슨 의미인지도 분명치 않아기계적으로 뭘 반대한다고?어떤 사양에 반해서.그럼 명세서는 어떻게 작성하나요?이것은, 프로그램의 모든 동작의 사양이 됩니다.그렇지 않았다면, 너는 그것이 해야 할 모든 것을 한다는 것을 증명하지 못했을 것이다.따라서 모든 작업에 대한 정식 사양을 가지고 있어야 합니다.자, 이제. 그 명세서를 어떻게 작성할 거야?아마 기능적인 언어로 쓰실 겁니다.그런 경우엔, 그게 네 프로그램일 수도 있어

이 함수는 "y의 제곱이 x가 되도록 함수의 결과"와 같은 프로그램에서 말할 수 없는 몇 가지 사양 언어로 말할 수 있기 때문에 저는 좀 더 빠르고 느슨합니다.이는 제곱근 함수에 적합한 사양이지만 실행 가능하지는 않습니다.그러나 프로그램이 해야 할 일을 모두 명기하려고 하면, 그 자체가 너무 복잡하기 때문에 그들이 의도한 바를 말할 자신이 없다고 생각합니다.

실제 생활에서 훨씬 더 생산적인 것은 프로그램이 가졌으면 하는 특성들을 적는 것이라고 생각합니다."이 밸브는 밸브와 동시에 닫히지 않아야 합니다.이 나무는 항상 균형이 잡혀 있어야 한다.이 함수는 항상 0보다 큰 결과를 반환해야 합니다."이것들은 모두 작은 부분 사양입니다.완전한 사양은 아닙니다.그냥 당신이 진실되고 싶은 것들이에요.

그걸 어떻게 적어요?음, 기능적인 언어들은 꽤 잘합니다.실제로 QuickCheck 사양을 작성할 때 Haskell 함수로 속성을 기록합니다.반전이 그 자체인지 확인하려고 합니다. A to bool 유형 목록을 사용하여 check reverse라고 쓸 수 있습니다.그래서 xs의 역수표는 xs의 역수표이고 xs의 역수표입니다.이 함수는 항상 true를 반환해야 합니다.그게 바로 속성 함수입니다.하지만 그건 그냥 같은 언어로 쓰여 있어. 그거 좋은 일이야.

이것에 대해서, 스태틱 체크를 실시해 주세요.힘들 수도 있고 쉬울 수도 있어요.하지만 공식적인 방법으로 재산을 적어두는 것조차 큰 도움이 됩니다.테스트 데이터를 생성하여 테스트를 수행할 수 있습니다. 이는 Quick Check가 실제로 수행하는 작업입니다.

따라서 프로그램에서 수행하는 모든 사양을 기록하려고 하는 것보다 일부 사양을 기록하는 것이 훨씬 생산적이라고 생각합니다.아마도 여러 부분 사양일 것이다.그런 다음 테스트 또는 동적 검사 또는 정적 검사를 통해 검사합니다.당신은 당신의 프로그램이 옳다는 것을 증명하지 못한다.당신은 단지 그것이 옳다는 자신감을 높일 뿐이다.그리고 난 그게 모두가 하는 일이라고 생각해.

Seibel: 그래서 당신은 당신이 관심을 가지는 것들을 포함하면서 얼마나 많은 속성을 정의한다.그런 다음 실제로 실행 가능한 속성에 따라 이러한 속성이 실제로 정적 또는 동적으로 유지되는지 확인할 수 있습니다.모든 것을 정적으로 확인하는 방법을 모르기 때문인가요?

Peyton Jones: 맞아요.하지만 기능적인 환경에서는 더 나은 가능성이 있습니다.하지만 우리는 그것을 입증하는 것에 대해 여전히 시간을 끌었습니다.단, 첫 번째 단계는 이러한 속성을 기록하는 것입니다.

하지만 중요한 것은 사양에 관한 일률적인 이야기에서 벗어나 부분 사양에 대해 유용한 정적 및 동적 테스트를 수행할 수 있다는 것입니다.이를 통해 프로그램의 정확성에 대한 자신감을 높일 수 있으며, 이것이 여러분이 기대할 수 있는 전부입니다.

완전한 사양도 빠뜨릴 수 있습니다.1초 안에 동작해야 합니다.또는 메모리 용량이 10KB여야 합니다.자원에 관한 것은 커버되지 않는 경우가 많습니다.아니면 시간을 재거나.프로그램이 정식 사양을 충족하더라도 실제로는 원하는 대로 작동하지 않을 수 있다는 것을 의미하는 작은 것들이 끝없이 있습니다.그래서 나는 우리가 실제로 모든 것이 완전히 옳다는 것을 증명했다고 말하는 것은 우리 스스로를 속이는 것이라고 생각한다.이를 인정하고 자신감을 높이고 있다고 말하는 것이 가장 좋은 방법입니다.그것이 바로 우리가 하고 있는 일입니다.처음에는 아주 가볍게 시작할 수 있습니다. 5%의 노력만으로 자신감을 75% 향상시켰을 수도 있습니다.그게 좋을 것 같아요.

동시성에 대해 조금 이야기해 봅시다.가이 스틸이 당신에게 묻습니다. "STM이 세상을 구할 수 있을까요?"

페이튼 존스:어쩌지.STM은 스스로 세상을 구하지 못할 것이다.동시성과 병렬 프로그래밍은 일반적으로 다방면에 걸친 야수이며 나는 그것이 단 한 발의 총탄에도 죽지 않을 것이라고 생각한다.동시성에 관한 한 저는 다양주의자입니다.

「동시 프로그램을 작성하기 위해서 하나의 프로그래밍 패러다임을 사용하고, 그것을 잘 실장하면 끝입니다.」라고 말하는 것은 유혹적입니다.사람들은 그 패러다임을 사용하여 동시 프로그램을 작성하는 방법을 배워야 합니다.하지만 난 믿을 수가 없어.어떤 스타일의 프로그래밍에서는 메시지 전달을 사용하는 것이 좋을 것 같습니다.다른 경우에는 STM을 사용하는 것이 좋습니다.다른 경우에는 데이터 병렬화가 훨씬 더 좋습니다.프로그래머는 그것을 하기 위해 여러 가지 방법을 고민해야 할 것이다.

하지만 STM이 잠금 및 조건 변수보다 더 나은가?지금 너는 비슷한 것과 비교하고 있다.네, 자물쇠와 조건 변수를 완전히 지배하고 있는 것 같아요그러니까 잠금장치와 조건변수는 잊어버려구요.여러 프로그램 카운터, 여러 스레드, 공유 메모리 멀티코어의 공유 메모리 디들링: STM. 그러나 동시 프로그램을 쓰는 유일한 방법입니까?절대로 그렇지 않아요.

STM에 대해 들은 비판 중 하나는 낙관적인 동시성은 당신이 원하는 만큼의 동시성을 허용하지 않는다는 것입니다.내 생각엔 당신이 정말 진척이 없는 이런 상황에서 꽤 쉽게 얻을 수 있다는 주장이었던 것 같아요.

페이튼 존스:당신은 기아를 걱정해야 합니다.여기서 제가 가장 좋아하는 예는 작은 거래가 들어와서 먼저 커밋하기 때문에 커밋하지 못하는 큰 트랜잭션입니다.예를 들어 라이브러리를 재구성하고 있는 사서가 그 예입니다.그들은 낙관적으로 라이브러리를 재구성하기 시작합니다.그들은 3분의 2를 통과했고 한 학부생이 와서 책을 빌렸습니다.도서관 개편이 이루어지지 않아서 거래를 성공적으로 성사시켰어요사서는 마지막에 가서 기억의 일관되지 않은 관점을 발견했습니다.왜냐하면 도서관을 재구성하는 동안 도서관이 바뀌었기 때문에 다시 돌아가서 다시 시작해야 하기 때문입니다.

Seibel: 잠금 및 조건 가변 프로그램에서는 아마도 다른 방향으로 갈 것입니다. 도서관 관리자는 도서관을 잠그고 도서관이 완전히 재편성될 때까지 아무도 책을 대출할 수 없습니다.그래서 아마 이 문제를 보고 바로 "끝날 때까지 도서관을 잠글 수 없다"고 대답할 것입니다. 체크아웃을 거부하기 때문에 좀 더 복잡한 잠금 방식을 고안해야 합니다.

Peyton Jones: 맞아요.도서관이나 뭐 그런 걸 좀 만들어 보세요. 대학생들이 메인 도서관을 잠그고 재정비하는 동안 대출할 수 있도록 흔히 빌리는 책들을 밖에 내놓으세요.이제 애플리케이션 고유의 전략을 생각하고 어떤 식으로든 표현해야 합니다.두 경우 모두 동일한 문제가 발생합니다. 모든 종류의 차입을 차단하고 싶지 않더라도 라이브러리를 재구성할 수 있도록 애플리케이션별 전략이 필요합니다.어떻게 하고 싶은지 곰곰이 생각해보고 나면, 이제 그걸 표현해야 해.그것을 표현하는 매체는 무엇입니까?STM은 확실한 승리입니다.이는 동시 프로그램을 표현하기 위한 잠금 및 조건 변수보다 훨씬 더 좋습니다.

세이벨: 만약 누군가가 들어와서 21번째로 가장 많은 책을 찾고 차단될 가능성조차 허락하고 싶지 않다면?실제 세계에서는 누군가가 책을 대출할 때 우리는 대리인을 통해 사서들이 다시 정리한 책과 교환하고, 책이 반환될 때마다 대리인이 있는 곳에 다시 놓아두는 것을 상상할 수 있습니다.하지만 당신은 라이브러리를 수정하고 있습니다.STM의 세계에서는 마치 도서관 관리자가 모든 거래를 재시도해야 하는 것처럼 보입니다.

페이튼 존스:하지만 변하지 않는 것이 있습니다. 책에 있는 열쇠는 어떻게든 변하지 않는다는 것을 보증합니다. 그렇죠?이렇게 할 수 있는 방법은 여러 가지 방법이 있습니다.예를 들어, "프록시로 교체할 때 수행하는 작업은 라이브러리를 전혀 수정하지 않는 것입니다."라고 말할 수 있습니다. 이는 변경되지 않습니다.당신이 하는 일은 책 자체를 수정하는 것입니다.키 필드는 수정하지 않고 현재 존재하는 값 필드만 수정합니다.이제 책이 다른 곳에 있는 동안 인덱스를 재구성할 수 있습니다.멋진데요. 그리고 당신은 그것을 완벽하게 자연스럽게 표현할 수 있어요.

STM을 사용하면 마지막으로 라이브러리 관리자는 읽은 모든 메모리 위치를 살펴보고 읽었을 때와 동일한 값을 포함하는지 확인합니다.그래서 그가 읽은 장소에는 책의 핵심 분야가 포함될 것입니다. 왜냐하면 그것이 그가 책을 어디에 두었는지를 결정했기 때문입니다.하지만 그는 책의 내용을 읽지 않았다.그래서 그는 "아, 이 책--이 키 필드에 아직 73이 들어있나요? 아, 들어있네요."라고 말합니다.

하지만 나는 기아의 문제를 최소화하고 싶지 않다. 왜냐하면 기아는 좀 음흉하기 때문이다.계속 부딪혀 커밋되지 않는 트랜잭션을 파악할 수 있는 좋은 프로파일링 툴이 필요합니다.이것에 의해서, 프로그램이 묵묵히 별로 행해지지 않는 대신에, 이것에 관한 피드백을 얻을 수 있습니다.잠금 기반 프로그램도 마찬가지입니다.나는 그 모래시계가 나타나는 것이 싫다.

Seibel: 잠금 기반 프로그램에서는 가능한 한 짧은 시간 동안 잠금 상태를 유지하는 방법을 배운 것 같습니다. 그러면 경합이 최소화되기 때문입니다.

Peyton Jones: 맞아요.하지만 물론 프로그래밍은 더 어렵습니다.세밀한 잠금장치는 올바르게 하기 어렵습니다.이것은 STM의 큰 장점 중 하나로 매우 세밀한 잠금과 매우 간단한 추론 원칙을 제공하는 것입니다.

여기 STM이 제공하는 잠금 장치가 절대 작동하지 않는 추론 원칙이 있습니다.최고 수준의 불변수를 설정할 거야은행 계좌가 많이 있는데, 모든 계좌에 있는 돈을 합친 합계가 N이에요. 돈이 은행 계좌 간에 이동해요. 그게 다예요.그래서 내 불변의 존재야.모든 트랜잭션은 처음에 변하지 않는다고 가정하고 마지막에 복원됩니다.어떻게 그렇게 생각하시나요?"저것에서 3개를 빼고 저것에서 3개를 넣으세요."라고 적혀 있는 트랜잭션을 살펴봅니다.좋아요.

불변성이 유지되었다.내 추론은 어떻게 이루어지는가?순수하게 순차적인 추론이죠상위 수준의 불변수를 설명하면 각 트랜잭션에 대해 완전히 순차적으로 추론할 수 있습니다.

Seibel: 트랜잭션 분리가 있기 때문입니다.

페이튼 존스:왜냐하면 그들은 격리되어 있기 때문이다.그래서 그것은 꽤 강력한 추리 원리입니다.프로그램이 동시에 실행되더라도 명령 코드에 대한 순차적 추론을 사용할 수 있다고 되어 있기 때문입니다.당신은 그 최상위 불변량이 무엇인지 밝혀야 합니다. 하지만 그것은 당신의 영혼에도 좋습니다.그래야 자신이 무엇을 유지하려고 하는지 알 수 있기 때문이다.트랜잭션 도중 예외가 발생하더라도 트랜잭션이 효과 없이 포기되기 때문에 불변수를 파괴할 수 없습니다.이건 정말 멋진 것 같아요.성능 문제에 대한 추론은 다른 수준입니다. 어느 정도 정확성을 보장받았으므로 이제 성능상의 결함이 없는지 확인해야 합니다.이러한 정보는 입수하기 어렵습니다.현재로서는 프로파일링과 피드백 툴을 지시하는 것 외에는 아무것도 모릅니다.

Seibel: 낙관적인 동시성이 영속적인 데이터베이스에서 때때로 사용되어 왔지만, 잠금 기반의 동시성에 비해 실제로 그 데이터베이스에는 발판을 마련하지 못했다는 생각이 듭니다.

Peyton Jones: 물론 STM은 모든 종류의 방법으로 구현될 수 있습니다. 낙관적인 동시성은 그 중 하나에 불과합니다.이동하면서 잠글 수 있습니다. 이는 비관적인 동시성 모델에 가깝습니다.

Seibel: 하지만 잠금 관리자가 데이터베이스에서 가장 중요한 부분인 이유도 있습니다.

Peyton Jones: 맞아요.STM의 중요한 점은 한 명 또는 한 팀이 STM을 구현하고 다른 모든 사람이 STM을 사용할 수 있도록 하는 것입니다.당신은 그들에게 많은 돈을 지불하고 그들이 정말 일을 잘하도록 확실히 하기 위해 1년 동안 그들을 작고 어두운 방에 가둘 수 있다.

이 작업은 매우 간단한 인터페이스를 통해 누구나 사용할 수 있습니다.그것이 내가 그것에 대해 좋은 것이라고 생각하는 것이다.내가 피하고 싶은 것은 모든 사람의 머릿속에 그 정도의 전문성을 갖는 것이다.어제 강연에서 사용한 예시는 Maurice Herlihy에서 가져온 것입니다.양단 큐: 요소 삽입 및 삭제입니다.

더블 엔드 큐의 순차적인 실장은 1학년 학부 프로그래밍 문제입니다.노드당 잠금 기능이 있는 동시 구현의 경우 연구 논문의 문제입니다.그건 너무 큰 발걸음이야.뭐가 그렇게 어려운 건 말도 안 돼요.트랜잭션 메모리는 또 학부 문제입니다.삽입 및 삭제 조작을 「원자성」으로 둘러싸면, 작업이 완료됩니다.정말 대단한 것 같아요.질적인 차이입니다.STM을 구현하는 사람들은 많은 변경을 하나의 메모리로서 원자적으로 커밋해야 합니다.비교와 교환만으로 쉽게 할 수 있는 그대로입니다.할 수는 있지만 조심해야 해요.

또한 성능 저하와 관련하여 성능 문제가 발생할 경우 이를 피할 수 있는 방법을 애플리케이션 차원에서 고려해야 할 수도 있습니다.하지만 다시 STM을 사용하여 애플리케이션 수준의 사고 결과를 표현합니다.나는 그런 종류의 프로그램을 위한 도약이라고 생각한다.

한 가지 더 언급하고 싶은 것이 있습니다. 기능적 프로그래밍으로 돌아갑니다.물론 STM은 기능 프로그래밍과는 전혀 관계가 없습니다.실제로는 공유 상태를 변환하는 것입니다. 그다지 기능적으로 들리지 않습니다.

근데 이게 무슨 일이냐면 자바에서 STM에 대해 팀 해리스가 한 강연에 갔었어요.나는 STM에 대해 들어본 적이 없다.그냥 우연히 그의 강연에 갔다.그는 자신이 "원자"를 가지고 있지만 다른 것은 거의 없는 STM에 대해 설명하고 있었다.이러한 원자성 트랜잭션을 구현할 수 있습니다.

"와, 정말 멋진데.아, 그래서 모든 부작용을 기억력에 기록해야 해.모든 로드 및 저장 지침.이런, 자바에는 이런 것들이 많이 있습니다."그러나 Haskell에서는 이러한 단일한 환경에서 발생하기 때문에 사실상 아무것도 없습니다.따라서 Haskell의 로딩 및 스토어는 매우 명확합니다.프로그래머들은 그것들을 큰 일로 생각하고 있습니다.

그래서 저는 생각했습니다. "아, 우리는 이 원자 기억 장치를 해스켈에서 복제해봐야 합니다. 왜냐하면 그것은 매우 멋진 기능이 될 것이기 때문입니다."그리고 우리는 떠났다. 나는 팀에게 이 일을 어떻게 해야 하는지에 대해 이야기했다.얼마 지나지 않아, 우리가 가지고 있던 프레임워크(이러한 종류의 순수하고 다소 여유로운 프레임 가치) 때문에, 우리는 재시도와 OrElse를 발명했습니다.Retry는 트랜잭션 내에서 블로킹을 수행할 수 있는 메커니즘이며 orElse는 트랜잭션 내에서 선택할 수 있는 비트입니다.Java용 트랜잭션 메모리를 개발하는 과정에서 그와 그의 동료에게 일어난 일은 아닙니다. 왜냐하면 그들의 컨텍스트의 나머지 부분이 상당히 복잡했기 때문입니다.

그래서 그들은 차단에 대해 별로 생각하지 않았습니다.또는 단순히 "이 술어가 유지될 때만 이 트랜잭션을 실행하라"고 말하는 방식이라고 가정했을 수도 있습니다.하지만 이는 매우 비구성적입니다. 한 은행 계좌에서 무언가를 꺼내 다른 은행 계좌에 넣으려고 한다면 거래가 실행될 수 있는 조건은 무엇일까요?답변: 첫 번째 은행 계좌에 충분한 돈이 있고 두 번째 은행 계좌에 충분한 공간이 있다면, 양쪽에 제한이 있다고 가정해 보겠습니다.그래서 그건 알아내기가 좀 복잡한 상황입니다.그리고 세 번째 은행 계좌가 관련되면 더 복잡해집니다.그것은 매우 비구성적이다. 당신은 그 방법들의 내부를 들여다보고 그 전제 조건들을 모두 앞으로 끌어내야 한다.

그것이 그가 가지고 있던 것이고 그것은 작은 프로그램들에서는 잘 작동했지만 분명히 매우 만족스럽지 않았다.그래서 Haskell의 컨텍스트에서 우리는 이 재시도, 즉 Else를 생각해 냈습니다.이것을 메인스트림의 필수 컨텍스트로 되돌리고 있습니다.또한 그들은 리트라이와 OrElse를 실행하느라 바쁩니다.잘됐네요.

그럼 하스켈에게 그 개념을 가능하게 한 것은 전혀 없는 건가요?그냥 그걸 생각할 수 있었던 거야?

페이튼 존스:그렇다.기본적으로 쓰레기가 적었기 때문에 멋진 아이디어가 눈에 띄었다.추상성을 잃지 않고 차단할 수 있는 방법이 없다는 것이 더 역겨워졌다.그래서 재시도하고 오르세(OrElse)를 하게 되었습니다.기능적 프로그래밍을 하기에는 정말 좋은 장소, 혹은 그 역할이 야수를 검사하는 일종의 실험실이라고 생각합니다.그리고 아이디어가 피드백이 될 수 있습니다.이 STM은 특히 명확한 예입니다.왜냐하면 양방향으로 변화가 있었기 때문입니다.여기 루프가 닫혀있었어요. 정말 사랑스럽다고 생각했어요.

프로그래머를 위한 사막 도서 목록은?

페이튼 존스:존 벤틀리의 '프로그래밍 진주'를 꼭 읽어보세요진주에 대해서 말하자면, 브라이언 헤이스는 아름다운 코드라는 제목의 이 책에서 "책의 집필 프로그램"이라는 사랑스러운 장을 가지고 있습니다. "책"은 영원한 아름다움을 지닌 프로그램을 의미한다고 생각합니다.두 점과 세 번째 점이 있고 이 세 번째 점이 두 점 사이의 어느 쪽에 있는지 찾아야 합니다.그리고 몇 가지 솔루션이 잘 작동하지 않습니다.하지만 그 후, 매우 심플한 솔루션이 있습니다.

물론, 돈 크누스의 시리즈, 컴퓨터 프로그래밍의 예술이죠.나는 그것이 내가 직접 읽은 어떤 것도 아니라고 생각한다. 그것은 그런 종류의 책이 아니다.나는 확실히 그것을 한 단계에서 많이 언급했다.Chris Okasaki의 책 Pure Functional Data Structures.환상적이에요.아서 노먼의 코스가 책 한 권에만 퍼진 것 같아요큐와 룩업 테이블과 힙을 부작용 없이 복잡도 경계가 좋은 방법으로 수행할 수 있는 방법에 대한 것입니다.정말, 정말 좋은 책이야이거 다 읽으셔야 돼요.또한 매우 짧고 쉽게 접근할 수 있습니다.컴퓨터 프로그램의 구조와 해석.애벨슨과 서스먼.나는 그것을 좋아했다.Andrew Appel의 책인 Compiling with Continuations는 Continuation passing 스타일을 사용하여 기능적인 프로그램을 컴파일하는 방법에 대한 책입니다.또한 훌륭합니다.

나에게 중요했지만 오랫동안 읽지 않은 책들: Dijkstra의 프로그래밍 훈련.Dijkstra는 아름다운 프로그램을 작성하는 데 매우 신중합니다.이것들은 절대적으로 필요하지만 명백한 버그가 없는 것이 아니라 분명히 버그가 없는 "Hoare 속성"을 가지고 있습니다.그리고 그것은 그것에 대해 논할 수 있는 매우 훌륭하고 우아한 논리를 제공합니다.그 책은 저에게 처음으로 프로그램에 대한 꽤 빈틈없는 추론을 소개시켜준 책입니다.당시 저에게 큰 인상을 남긴 또 다른 책은 동시 운영체제 작성에 관한 Per Brinch Hansen의 책이었습니다.많이 읽었어요.

아직도 프로그램 많이 해?

페이튼 존스:아네.나는 매일 코드를 몇 개 쓴다.사실 매일은 아니지만 그게 내 주문이야나는 어떤 것에든 능숙한 사람들이 승진하거나 그들이 잘하는 일을 더 이상 하지 못할 때까지 더 중요해질 수 있는 끔찍한 위험이 있다고 생각한다.여기서 일하면서 일반적으로 연구를 하는 것이 마음에 드는 것 중 하나는 1990년부터 작업해 온 컴파일러를 계속 사용할 수 있다는 것입니다.

이것은 큰 코드 조각이고, 많은 코드 조각들이 있기 때문에 제가 가장 잘 알고 있는 사람입니다.

얼마나 많은 코드를 작성해야 합니까?어떤 날은 하루 종일 프로그래밍을 하면서 코드를 쳐다보기도 해요다른 날은, 하나도.아마 평균적으로 하루에 몇 시간 정도 걸릴 겁니다.프로그래밍은 정말 재미있어요.왜 안 하려고 해?게다가 자신의 컴파일러를 사용하고, 자신이 지지하는 언어를 사용하는 것은, 리얼리티 체크에 도움이 됩니다.

아직도 처음처럼 프로그래밍을 즐기시나요?

페이튼 존스:아, 네, 네.그게 제일 재밌어요.나는 대부분의 프로그래머들이 "이것을 할 수 있는 좋은 방법이 있을 것"이라는 느낌을 가지고 있다고 생각한다.연구 업무의 좋은 점 중 하나는 매니저가 "이번 주에 끝내야 한다.그냥 끝내면 된다"고 말하는 대신 앉아서 무언가를 보고 "이 일을 하는 올바른 방법이 있을 것이다."라고 말할 수 있다는 것입니다.

그래서 저는 인터페이스를 리팩터링하고 이동하며 새로운 타입을 쓰거나 심지어 그것을 바로잡기 위해 전체 블롭을 다시 쓰는 데 많은 시간을 소비합니다.GHC는 꽤 큰 편입니다.산업 표준으로 보면 큰 편은 아닙니다.기능 프로그래밍 표준으로 보면 큰 편입니다.약 8만 회선, 어쩌면 조금 더 많을지도 모릅니다.그리고 수명이 길죠. 이제 15년이 됐어요.아직 활발히 개발되고 있다는 것은 덩어리가 다시 작성되었음을 나타냅니다.만질 수 없는 것은 없다.그래서 무언가를 보고 "이렇게 하는 올바른 방법은 무엇일까요?"라고 생각하는 것은 도전적이면서도 즐거운 일입니다.그리고 종종 나는 무언가에 대해 몇 주 동안 미루곤 하지만 그것을 할 좋은 방법이 생각나지 않는다.하지만 감질나네요.좋은 방법이 있을 테니까

그 몇 주 동안 무슨 일이 벌어지나요?

페이튼 존스:오, 나는 마음속으로 그것에 대해 생각하고 있어요.그리고 가끔은 나도 한번 해 볼 거야. 난 언덕을 좀 뛰어 올라가거든.그리고 왜 그렇게 복잡한지 기억합니다. 그리고 보통 다른 변위 활동이 일어납니다.그래서 가끔 이 언덕을 여러 번 뛰어오릅니다.가끔 뒤에서 생각하기도 해요.그리고 가끔은 "이제 시간이 다 됐어. 이제 뭔가 해야 해."라고 생각할 때가 있습니다.어쩌면 그렇게 아름답지 않을 수도 있어요

세이벨: 아침에 일어나서 "아, 알았어!"라고 말하는 그런 거야?아니면 한 번 더 달려보기로 결심하고 이번에는 언덕 꼭대기에 도달한 건가요?

페이튼 존스:그런 것 같아요.아침에 눈이 부신 적이 거의 없어요.연구자로서 일어나는 또 다른 일은 여러분이 한 일에 대해 반성하고 쓸 수 있는 기회가 있다는 것입니다.그래서 흥미로운 일이 생겼을 때 나는 그것에 대해 논문을 쓰려고 한다.예를 들어 'GHC 인라이너의 비밀'이라는 논문이 있습니다GHC 내장의 특정 부분을 위해 개발한 구현 기술을 설명하는 매우 구현 지향적인 논문입니다.다른 사람이 재사용할 수 있을 것으로 생각됩니다.학자로서 얻을 수 있는 기회는 코드에서 추출하는 것입니다.코드에서 네 번째, 마침내 기분 좋은 모양으로 만들어 다른 사람들이 같은 기술을 재사용할 수 있도록 글쓰기를 하는 것입니다.

당신에게 프로그래밍이란 무엇입니까?당신은 자신을 과학자, 엔지니어, 장인이라고 생각합니까?아니면 완전히 다른 거?

페이튼 존스:프레드 브룩스의 "툴스미스로서의 컴퓨터 과학자"라는 논문을 읽어보셨나요?최근에 다시 읽었어요.아주 좋아요.우리가 무언가를 만드는 것에 관심이 있다는 것을 기억하는 것이 좋을 것 같습니다.그래서 프로그래밍이 재미있는 것 같아요.

동시에 나는 지속적 가치의 원칙을 도출하는 데 매우 열심이다.저는 어떻게 하면 좋은 논문을 쓸 수 있는지, 좋은 연구를 할 수 있는지에 대한 논문을 가지고 있습니다. 그리고 가장 중요한 부분 중 하나는 '유물을 묘사하지 말라'는 것입니다.아티팩트는 아이디어를 구현한 것입니다.청취자의 머릿속에 전달하려는 재사용 가능한 두뇌의 아이디어는 무엇일까요?그들에게 유용한 무언가가 있다.구체적인 유물에서 재사용할 수 있는 아이디어를 추출하는 것이 학계의 일이라고 생각합니다.법칙을 발견한다는 것은 아직 과학이 아닙니다.하지만 그것은 내가 매우 중요하다고 생각하는 현실의 늪에서 다시 사용할 수 있는 생각들로의 일종의 추상화이다.

그럼 공학과 공예는 어떨까요?우리는 다리를 건설하는 사람들처럼 다리가 무너지지 않을 거라고 예상해야 할까요?아니면 정말 도자기를 만드는 사람과 같은 걸까요?그냥 복잡한 도자기는 제외하고요.다른 사람의 견습생으로 도예하는 것 밖에 할 수 없는 거죠?

페이튼 존스:약간 잘못된 이분법이죠이건 정말 둘 중 어느 쪽이든 선택할 수 있는 그대로야.전문 소프트웨어 엔지니어나 개발자에게도 어려운 것은 작업하는 아티팩트의 크기를 직감적으로 파악하는 것입니다.당신은 1피트 정사각형의 포트홀을 통해 엠파이어 스테이트 빌딩을 보고 있기 때문에 당신이 보고 있는 건물이 얼마나 거대한지 실감하기 어렵다.그리고 어떻게 연결되어 있는지.

GHC의 크기는?나는 이 건물이 얼마나 큰지 느끼는 것과 같은 의미에서 그것에 대한 감이 없다.그래서 저는 우리가 다리를 건설하는 엔지니어가 있는 곳 근처에 있다고 생각하지 않습니다.그들의 디자인 패턴은 이제 다리가 무너지지 않을 것이라고 거의 확신할 수 있을 정도로 압축되었다.소프트웨어로는 전혀 미치지 못합니다.하지만 나는 그것이 우리가 그것에 대해 전혀 걱정하지 말아야 한다고 말하는 이유라고 생각하지 않는다.

실제로 기능적 프로그래밍이 제공하는 것이 많은 곳이라고 생각합니다.왜냐하면 기본적으로는 보다 견고한 구조를 만들 수 있다고 생각하기 때문입니다.이해하기 쉽고 테스트 및 추론하기 쉬운 구조.여기 기능 프로그래머가 뒤떨어져 있는 것이 있습니다.기능 프로그램에 대해서는 논하지만 잘 하지 않습니다.저는 Haskell 프로그램을 이해하고 공식적으로 그 프로그램에 대해 논하고 그 유형의 보증을 제공하는 도구를 통해 더 많은 것을 보고 싶습니다.우리는 더 높은 플랫폼에 서 있기 때문에 더 멀리 갈 수 있을 것이다.

즉, 소재가 보다 견고해져야 한다는 것입니다.재료가 견고할수록 대규모 구조 대신 세세한 부분에 집중할 필요가 줄어듭니다.물론 그것은 우리가 더 큰 건물을 짓겠다는 야망을 다시 무너지는 지경에 이를 때까지 만들 것이다.

나는 그것이 일종의 불변이라고 생각한다.할 수 있게 되면 더 이상 할 수 없을 정도로 스트레칭이 됩니다.난 별로 그렇게 생각하지 않는 것 같은데, 이건가, 저건가?우리가 야망을 확장한다는 이유만으로 항상 강한 교활한 요소가 있을 것이다.엔지니어링 구조물의 경우, 연장할 수 있는 거리에는 물리적 한계가 있습니다.대서양을 가로지르는 다리는 당분간 아무도 건설하지 않을 것이다.그리고 만약 당신이 그것을 지으면 그것은 무너질지도 모른다.하지만 그렇다고 해서 사람들이 구축하지 않는 것은 아닙니다. 단지 비용이 너무 많이 들기 때문입니다.하지만 요즘은 소프트웨어를 통해 해협에 빠르고 저렴하게 다리를 건설할 수 있게 되면그건 이미 끝난 일이 되어버렸습니다그게 꽤 저렴하다고 생각하기 때문에 이제 대서양을 시험해 보겠습니다그리고 지금은 다시 무너지고 있다.

세이벨: 가이 스틸은 무어의 법칙이 그의 경력 전반에 걸쳐 어떻게 사실이었는지를 말하고 있었고, 그는 그것이 그의 아들의 경력 전체에 대해 사실이 아닐 것이라고 의심하고 그것이 프로그래밍에 어떤 영향을 미칠지에 대해 약간 추측하고 있었다."만일 우리가 해협 위에 다리를 건설할 수 있다면, 대서양 위에 다리를 건설할 수 있다"고 말하는 것을 끝내야 할지 궁금하다.

Peyton Jones: 아니, 아니.소프트웨어는 다른 것 같아요.왜냐하면 10배 큰 소프트웨어를 쓴다고 해서 10배 빠른 컴퓨터에서 실행할 필요는 없기 때문입니다.프로그램 카운터는 코드의 작은 부분에 시간을 소비합니다.시간의 90퍼센트는 코드의 10퍼센트에 소비됩니다.따라서 퍼포먼스가 중요한 부분은 프로그램에서 비교적 작은 부분일 수 있습니다.

실제로 어떤 일이 일어나려면 추상화를 추상화 위에 덧씌우고, 화면의 버튼 하나를 누르기도 전에 수많은 일이 연쇄적으로 일어납니다.

따라서 복잡한 컴파일러 변환을 통해 이러한 레이어를 분해하는 방법을 강구해야 할 수 있습니다.추상화 경계는 사람들에게 유용할 수 있지만 기계는 신경 쓰지 않는다.따라서 컴퓨터가 무엇을 할 수 있는지에 대한 경계에 도달했다고 해서 소프트웨어가 복잡해지는 것을 즉시 멈출 수 있다고는 생각하지 않습니다.어차피 그때쯤이면 꽤 빠를 테니까소프트웨어의 주된 제한은 컴퓨터의 속도가 아니라 소프트웨어의 기능을 이해하는 능력이라고 생각합니다.

세이벨: 프로그래밍의 어떤 점이 좋습니까?

페이튼 존스:저에게 있어서 프로그래밍을 재미있게 만드는 것의 일부는 지적 무결성을 가진 프로그램을 작성하려고 하는 것입니다.프로그램 쪽에서 계속 진흙탕을 칠 수 있고, 그것은 그저 오랫동안 작동하게 만들 뿐이지만 그다지 만족스럽지는 않다.구프로그래머의 좋은 특성은 아름다운 해결책을 찾는 것입니다.모든 사람이 아름다운 방법을 생각해 낼 수 없기 때문에 오늘 일을 끝낼 수 없는 사치를 누리는 것은 아닙니다.

하지만 정말 재미있는 매체라고 생각해요. 왜냐하면 너무 유연하기 때문이죠.이것으로 거의 모든 것을 할 수 있습니다.하지만 그것은 추악한 것뿐만 아니라 아름다운 것들도 만들 수 있다는 것을 의미합니다. 전혀 유지보수가 불가능하고 지속할 수 없는 것들도요.다음 주에 고객이 필요로 하기 때문에, 또 다른 한편으로, 델이 구축하는 시스템의 깊이가 아니라, 지극히 폭넓은 것을 필요로 하는 비즈니스 세계에 대해서, 때때로 조금 불안감을 느낍니다.

ASP를 구축하기 위해 시스템은 매우 많은 goop으로 가득 차 있습니다.NET Web Service-y는 이 API와 툴에 대해 알아야 하며, 3가지 언어로 작성해야 하며, Silverlight와 LINQ에 대해 알아야 하며, 줄임말을 영원히 사용할 수 있습니다.그리고 그들은 각각 그것을 설명하는 두꺼운 책을 가지고 있다.

이 긴장감은 어떻게 풀어야 할지 모르겠어요.이것들은 유용한 시스템이다. 우연히 설계된 것이 아니다.그들 각각은 이유가 있고, 어떻게 설계해야 할지 고민하는 똑똑한 사람을 가지고 있습니다.다만, 각각은 개별적으로 넓은 인터페이스를 가지고 있습니다.깊을 수도 있고 아닐 수도 있지만 확실히 넓다.머릿속에만 담아두면 되는 게 많잖아그것은 마치 언어를 배우는 것과 같습니다. 인간의 언어를 배우는 것과 같습니다. 많은 어휘가 있습니다.

저는 그게 재미없어요.나는 구구단을 배운 적이 없다.저는 항상 그것들을 첫 번째 원칙부터 알아냈고, 충분히 빨리 할 수 있을 만큼 충분히 많은 속임수를 개발했습니다.당신이 7.99를 할 때, 나는 여전히 7.99를 가야 하고, 7을 빼고 10을 빼면 63이 된다.반면에 다른 사람들은 그걸 막 배웠지그리고 그것은 비교적 작은 것입니다.그래서 난 네가 이런 큰 것들을 배워야 하는 게 싫어.그래서 본능적으로 나는 이 큰 구피 같은 것들로부터 물러난다.그러나 동시에 나는 그것들이 실제로 유용하고 중요하다는 것을 인정한다.여기서 궁금한 것은, 이러한 것을 설계하는 데 시간을 조금 더 들일 수 있다면, 보다 작고 복잡하지 않으며, 보다 적은 애드혹 인터페이스로 설계할 수 있을까 하는 것입니다.

세이벨: 때때로 그것은 정확히 이들 각자가 똑똑한 사람 또는 그것을 위해 일하고 있는 사람들을 가지고 있고, 각각의 똑똑한 사람들은 놀 수 있는 그들만의 작은 놀이터를 원하기 때문에 일이 너무 복잡해지기 때문인 것처럼 보인다.

페이튼 존스:분명 그런 요소도 있을 거예요하지만 좀 더 긍정적인 해석을 하자면, 세상은 넓고 복잡해서 할 일이 많습니다.거대한 올림피아식 비전을 가지고 있다면, 매우 큰 두뇌와 엄청난 스루풋을 가지고 있다면, 오버랩을 줄이고 전체적인 일관성을 높인 무언가를 할 수 있을 것입니다.

그러나 실제로는 이러한 문제를 작은 덩어리로 나누어 고려해야 합니다.그리고 그 작은 덩어리들은 각각 그것을 돌봐주는 누군가가 있고, 그들이 이전에 해왔던 것과 그들의 유산에 의해 조절됩니다.즉, 그 공간 내에서 시간이 촉박하기 때문에 가능한 한 좋지 않은 것을 설계하는 것일 수도 있습니다.그리고 확실히 모든 것을 조합할 때쯤에는 가능한 것보다 훨씬 덜 좋을지도 모릅니다.그리고 어느새 레거시 문제에 빠져들게 됩니다.그것도 상황이 가능한 한 좋지 않은 이유입니다.

그래서 엄청난 유산들이 끌려다니고 있습니다.해스켈의 좋은 점 중 하나죠제가 Haskell에 대한 회고전을 열었을 때, 저는 Haskell에서 우리가 배운 것 중 하나가 "어떤 대가를 치르더라도 성공을 피하는 것"이라는 것을 보여주는 슬라이드를 올렸습니다.이것은 분명히 밈의 일종입니다왜냐하면 사람들은 그 문구를 기억하고 있기 때문입니다

그것은 일말의 진실성을 가지고 있습니다. 왜냐하면 너무 일찍 성공하지 못함으로써 우리는 해스켈을 일생 동안 꽤 많이 변형시킬 수 있었기 때문입니다.그리고 제가 지금 약간 정신이 없는 이유 중 하나는 Haskell이 더 성공적이기 때문에 버그 보고서와 기능 요청이 더 많이 들어왔기 때문입니다.그리고 더 많은 사람들이 "제 프로그램을 망치지 마세요."라고 말한다.전에는 그런 일이 없었어요.

Seibel: 당신은 아름다운 코드를 쓰는 것을 몇 번 언급했습니다.아름다운 코드의 특징은 무엇입니까?

페이튼 존스:Tony Hoare는 당신의 코드에 버그가 없어야 한다고 말하는 훌륭한 어구를 가지고 있습니다.그래서 저는 아름다운 코드가 맞는 코드라고 생각합니다.투명하고 투명합니다.

어떻게 동작하는지 알아내야 하는 코드의 작은 보석들은요? 하지만 한번 알아냈을 때 정말 놀라워.그것들도 아름답나요?

페이튼 존스:때때로 그것이 명백하게 옳다고 말하는 것은 정신적 발판 없이 그것이 옳다는 것을 알 수 있다는 것을 의미하지 않는다.그것이 왜 옳은지 알아내는 통찰력이 필요할 수도 있다.AVL 트리의 코드를 보면, 무엇을 달성하려고 하는지 알 수 없다면, 왜 이러한 회전이 일어나고 있는지 알 수 없을 것입니다.그러나 일단 이 불변성을 파악하면, 이 불변성을 유지하면 이 불변성을 유지할 수 있습니다.그리고 코드의 각 행을 보고 "아, 그래, 불변성을 유지하는구나"라고 말합니다.그래서 불변성이란 "오, 분명히 맞는 말이구나"라고 말할 수 있는 통찰력입니다.

코드만 보고는 충분하지 않을 수 있다는 것에 전적으로 동의합니다.그냥 코드만 보고 왜 옳은지 알 수 있는 건 아름다운 코드의 특징이 아니라고 생각합니다.왜 그런지 알아야 할 것 같아요.하지만 그 시점, 그 시점, 그 불변, 무슨 일이 일어나고 있는지 이해하면, 아, 그래, 맞아.

Seibel: 그러면 소프트웨어의 크기가 얼마나 큰지, 그리고 여전히 아름다운지에 대한 상한을 둘 수 있을까요?

페이튼 존스:사이즈에 제한이 있는지는 모르겠습니다.그것이 옳다고 확신하기 위해 필요한 통찰력은 그것이 옳다고 확신하는 것과 비슷합니다.정말 큰 소프트웨어에는 결점이 있기 마련입니다.잘못된 것을 알고 있는 것은 분명합니다.하지만 지금 고치는 것은 경제적이지 않다.이것은 확실히 GHC에도 해당되고 마이크로소프트 소프트웨어에도 해당됩니다.

그러나 빅 소프트웨어를 관리하기 쉽게 만드는 것은 그것이 무엇을 해야 하는지, 무엇이 진실이어야 하는지에 대한 글로벌 불변성 또는 큰 그림을 그리는 진술입니다.그래서 GHC를 예로 들자면, 이러한 중간 프로그램들은 각각 잘 타이핑되어야 한다는 불변성을 가지고 있습니다.

원한다면 런타임에 확인할 수 있습니다.그것은 무슨 일이 일어나고 있는지에 대한 꽤 강력한 불변이다.그래서 꼭 사이즈와 관련이 있는지는 잘 모르겠습니다.

확실히 상호 연결성은 결국 큰 프로그램들을 자체 무게에 짓눌리게 만듭니다.연구를 통해 얻을 수 있는 사치 중 하나는 때로는 코드 덩어리를 가지고 무엇을 달성하려고 노력했는지, 어떻게 달성하려고 노력했는지에 대한 향상된 통찰력을 고려하여 간단히 다시 쓸 수 있다는 것입니다.우리는 GHC 백엔드를 리팩터링하는 이 사업에 대해 이야기했다.만약 내가 좀 더 상업적인 환경에서 일한다면, 나는 그것을 할 여유가 없을지도 모른다.하지만 나는 그것이 장기적으로 GHC를 더 유지 보수하고 이해하기 쉽게 만들기를 바란다.

사이즈에 상한선이 있나요?나는 모른다.저는 오히려 우리가 좋은 추상화들을 계속 건설할 수 있는 한 대서양을 가로지르는 다리를 계속 건설할 수 있다고 생각합니다.우리에게는 작동하는 소프트웨어가 있습니다. 완벽하게 작동하지는 않지만, 그 크기를 고려하면 놀랄 만큼 훌륭합니다.

그래서 질문은 그 정도로 크고 잘 작동하고 아름다운 건물을 지을 수 있느냐는 것입니다.

페이튼 존스:그것은 아름다움을 유지하는 것이 어렵다.비트는 종종 아름답거나 적어도 처음 만들어졌을 때는 못생기지 않습니다.장기화된 수명, 즉 유지보수에 직면하여 유지보수가 매우 어렵습니다.그게 장수 프로그램의 가장 나쁜 점이야... 점점 못생겨진다는 거지.그래서 그들은 단 한순간도 변질되지 않았지만 그래도 시간이 지나면 그냥 엉망으로 변한다.

"좋아, 이 물건은 충분히 오래 살았어, 다시 시작해"라고 말할 수 있는 유일한 방법인가?

페이튼 존스:결국엔 그 부분을 다시 설계해야 할 것 같아요만약 당신이 진행하면서 약간의 재엔지니어링을 할 여유가 있다면, 만약 당신이 10년 동안 아무것도 하지 않는다면, 그 결과는 매우 부담스러울 것이다. "그냥 버리고 다시 시작해야 한다."인간세포가 스스로 재생하는 것처럼그만큼 재엔지니어링을 할 수 있다면GHC도 그렇게 됐으면 좋겠어요

프로그래머로서의 삶에서 가장 우울한 점은 다른 사람이 쓴 코드 덩어리에 직면하거나 더 나쁜 것은 스스로 썼지만 더 이상 수정할 엄두가 나지 않는다는 것입니다.우울하네요.
